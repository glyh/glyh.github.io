<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>SICP Solutions in Clojure (Chapter 2) - Newbie@Corner</title><meta name="description" content=""><meta property="og:title" content="SICP Solutions in Clojure (Chapter 2)" />
<meta property="og:description" content="Exercise 2.1
(defn make-rat [n d] 
  (let [g (gcd n d) nf (/ n g) df (/ d g)] 
    (if (&lt; df 0) (list (- nf) (- df)) 
                      (list nf df) )))
Exercise 2.2
(defn make-point [x y] (list x y))
(def x-point first)
(def y-point second)

(defn make-segment [s t] (list s t))
(def start-segment first)
(def end-segment second)

(defn midpoint-segment [seg] 
  (map #(/ (&#43; (% (start-segment seg)) (% (end-segment seg))) 2) 
       [x-point y-point]))

(defn print-point [p] (prn (str &#34;(&#34; (x-point p) &#34;, &#34; (y-point p) &#34;)&#34;)))
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://glyh.github.io/posts/sicp-solutions-in-clojure-chapter-2/" />
<meta property="article:published_time" content="2021-02-03T16:39:00+08:00" />
<meta property="article:modified_time" content="2021-02-03T16:39:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SICP Solutions in Clojure (Chapter 2)"/>
<meta name="twitter:description" content="Exercise 2.1
(defn make-rat [n d] 
  (let [g (gcd n d) nf (/ n g) df (/ d g)] 
    (if (&lt; df 0) (list (- nf) (- df)) 
                      (list nf df) )))
Exercise 2.2
(defn make-point [x y] (list x y))
(def x-point first)
(def y-point second)

(defn make-segment [s t] (list s t))
(def start-segment first)
(def end-segment second)

(defn midpoint-segment [seg] 
  (map #(/ (&#43; (% (start-segment seg)) (% (end-segment seg))) 2) 
       [x-point y-point]))

(defn print-point [p] (prn (str &#34;(&#34; (x-point p) &#34;, &#34; (y-point p) &#34;)&#34;)))
"/>
<meta name="application-name" content="Newbie@Corner">
<meta name="apple-mobile-web-app-title" content="Newbie@Corner"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://glyh.github.io/posts/sicp-solutions-in-clojure-chapter-2/" /><link rel="next" href="https://glyh.github.io/posts/sicp-solutions-in-clojure-chapter-1/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "SICP Solutions in Clojure (Chapter 2)",
        "inLanguage": "en-us",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/glyh.github.io\/posts\/sicp-solutions-in-clojure-chapter-2\/"
        },"genre": "posts","keywords": "algorithms, principles, LISP","wordcount":  5700 ,
        "url": "https:\/\/glyh.github.io\/posts\/sicp-solutions-in-clojure-chapter-2\/","datePublished": "2021-02-03T16:39:00+08:00","dateModified": "2021-02-03T16:39:00+08:00","publisher": {
            "@type": "Organization",
            "name": "lyhokia"},"author": {
                "@type": "Person",
                "name": "lyhokia"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Newbie@Corner">Newbie@Corner</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Newbie@Corner">Newbie@Corner</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title"></h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">SICP Solutions in Clojure (Chapter 2)</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>lyhokia</a></span>&nbsp;<span class="post-category"></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-02-03">2021-02-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span></span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#exercise-21">Exercise 2.1</a></li>
        <li><a href="#exercise-22">Exercise 2.2</a></li>
        <li><a href="#exercise-23">Exercise 2.3</a></li>
        <li><a href="#exercise-24">Exercise 2.4</a></li>
        <li><a href="#exercise-25">Exercise 2.5</a></li>
        <li><a href="#exercise-26">Exercise 2.6</a></li>
        <li><a href="#exercise-27">Exercise 2.7</a></li>
        <li><a href="#exercise-28">Exercise 2.8</a></li>
        <li><a href="#exercise-29">Exercise 2.9</a></li>
        <li><a href="#exercise-210">Exercise 2.10</a></li>
        <li><a href="#exercise-211">Exercise 2.11</a></li>
        <li><a href="#exercise-212">Exercise 2.12</a></li>
        <li><a href="#exercise-213">Exercise 2.13</a></li>
        <li><a href="#exercise-214">Exercise 2.14</a></li>
        <li><a href="#exercise-215">Exercise 2.15</a></li>
        <li><a href="#exercise-216">Exercise 2.16</a></li>
        <li><a href="#exercise-217">Exercise 2.17</a></li>
        <li><a href="#exercise-218">Exercise 2.18</a></li>
        <li><a href="#exercise-219">Exercise 2.19</a></li>
        <li><a href="#exercise-220">Exercise 2.20</a></li>
        <li><a href="#exercise-221">Exercise 2.21</a></li>
        <li><a href="#exercise-222">Exercise 2.22</a></li>
        <li><a href="#exercise-223">Exercise 2.23</a></li>
        <li><a href="#exercise-224">Exercise 2.24</a></li>
        <li><a href="#exercise-225">Exercise 2.25</a></li>
        <li><a href="#exercise-226">Exercise 2.26</a></li>
        <li><a href="#exercise-227">Exercise 2.27</a></li>
        <li><a href="#exercise-228">Exercise 2.28</a></li>
        <li><a href="#exercise-229">Exercise 2.29</a></li>
        <li><a href="#exercise-230">Exercise 2.30</a></li>
        <li><a href="#exercise-231">Exercise 2.31</a></li>
        <li><a href="#exercise-232">Exercise 2.32</a></li>
        <li><a href="#exercise-233">Exercise 2.33</a></li>
        <li><a href="#exercise-234">Exercise 2.34</a></li>
        <li><a href="#exercise-235">Exercise 2.35</a></li>
        <li><a href="#exercise-236">Exercise 2.36</a></li>
        <li><a href="#exercise-237">Exercise 2.37</a></li>
        <li><a href="#exercise-238">Exercise 2.38</a></li>
        <li><a href="#exercise-239">Exercise 2.39</a></li>
        <li><a href="#exercise-240">Exercise 2.40</a></li>
        <li><a href="#exercise-241">Exercise 2.41</a></li>
        <li><a href="#exercise-242">Exercise 2.42</a></li>
        <li><a href="#exercise-243">Exercise 2.43</a></li>
        <li><a href="#exercise-244">Exercise 2.44</a></li>
        <li><a href="#exercise-245">Exercise 2.45</a></li>
        <li><a href="#exercise-246">Exercise 2.46</a></li>
        <li><a href="#exercise-247">Exercise 2.47</a></li>
        <li><a href="#exercise-248">Exercise 2.48</a></li>
        <li><a href="#exercise-249">Exercise 2.49</a></li>
        <li><a href="#exercise-250">Exercise 2.50</a></li>
        <li><a href="#exercise-251">Exercise 2.51</a></li>
        <li><a href="#exercise-252">Exercise 2.52</a></li>
        <li><a href="#exercise-253">Exercise 2.53</a></li>
        <li><a href="#exercise-254">Exercise 2.54</a></li>
        <li><a href="#exercise-255">Exercise 2.55</a></li>
        <li><a href="#exercise-256">Exercise 2.56</a></li>
        <li><a href="#exercise-257">Exercise 2.57</a></li>
        <li><a href="#exercise-258">Exercise 2.58</a></li>
        <li><a href="#exercise-259">Exercise 2.59</a></li>
        <li><a href="#exercise-260">Exercise 2.60</a></li>
        <li><a href="#exercise-261">Exercise 2.61</a></li>
        <li><a href="#exercise-262">Exercise 2.62</a></li>
        <li><a href="#exercise-263">Exercise 2.63</a></li>
        <li><a href="#exercise-264">Exercise 2.64</a></li>
        <li><a href="#exercise-265">Exercise 2.65</a></li>
        <li><a href="#exercise-266">Exercise 2.66</a></li>
        <li><a href="#exercise-267">Exercise 2.67</a></li>
        <li><a href="#exercise-268">Exercise 2.68</a></li>
        <li><a href="#exercise-269">Exercise 2.69</a></li>
        <li><a href="#exercise-270">Exercise 2.70</a></li>
        <li><a href="#exercise-271">Exercise 2.71</a></li>
        <li><a href="#exercise-272">Exercise 2.72</a></li>
        <li><a href="#exercise-273">Exercise 2.73</a></li>
        <li><a href="#exercise-274">Exercise 2.74</a></li>
        <li><a href="#exercise-275">Exercise 2.75</a></li>
        <li><a href="#exercise-276">Exercise 2.76</a></li>
        <li><a href="#exercise-277">Exercise 2.77</a></li>
        <li><a href="#exercise-278281-283--285">Exercise 2.78~2.81, 2.83 ~ 2.85</a></li>
        <li><a href="#exercise-281">Exercise 2.81</a></li>
        <li><a href="#exercise-282">Exercise 2.82</a></li>
        <li><a href="#exercise-286">Exercise 2.86</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h3 id="exercise-21">Exercise 2.1</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">make-rat</span> <span class="p">[</span><span class="nv">n</span> <span class="nv">d</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">g</span> <span class="p">(</span><span class="nf">gcd</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">nf</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">n</span> <span class="nv">g</span><span class="p">)</span> <span class="nv">df</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">d</span> <span class="nv">g</span><span class="p">)]</span> 
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">df</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">- </span><span class="nv">nf</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">df</span><span class="p">))</span> 
                      <span class="p">(</span><span class="nb">list </span><span class="nv">nf</span> <span class="nv">df</span><span class="p">)</span> <span class="p">)))</span>
</code></pre></div><h3 id="exercise-22">Exercise 2.2</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">make-point</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nb">list </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">x-point</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">y-point</span> <span class="nv">second</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-segment</span> <span class="p">[</span><span class="nv">s</span> <span class="nv">t</span><span class="p">]</span> <span class="p">(</span><span class="nb">list </span><span class="nv">s</span> <span class="nv">t</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">start-segment</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">end-segment</span> <span class="nv">second</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">midpoint-segment</span> <span class="p">[</span><span class="nv">seg</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">%</span> <span class="p">(</span><span class="nf">start-segment</span> <span class="nv">seg</span><span class="p">))</span> <span class="p">(</span><span class="nf">%</span> <span class="p">(</span><span class="nf">end-segment</span> <span class="nv">seg</span><span class="p">)))</span> <span class="mi">2</span><span class="p">)</span> 
       <span class="p">[</span><span class="nv">x-point</span> <span class="nv">y-point</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-point</span> <span class="p">[</span><span class="nv">p</span><span class="p">]</span> <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">str </span><span class="s">&#34;(&#34;</span> <span class="p">(</span><span class="nf">x-point</span> <span class="nv">p</span><span class="p">)</span> <span class="s">&#34;, &#34;</span> <span class="p">(</span><span class="nf">y-point</span> <span class="nv">p</span><span class="p">)</span> <span class="s">&#34;)&#34;</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-23">Exercise 2.3</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure">
<span class="c1">; Implementation 1</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">make-rectangle</span> <span class="p">[</span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">]</span> <span class="p">(</span><span class="nb">list </span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">))</span> 

<span class="p">(</span><span class="k">def </span><span class="nv">abs</span> <span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">%</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">%</span><span class="p">)</span> <span class="nv">%</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">diff</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nf">abs</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">b</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">width</span> <span class="o">#</span><span class="p">(</span><span class="nf">diff</span> <span class="nv">x-point</span> <span class="p">(</span><span class="nf">start-segment</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">end-segment</span> <span class="nv">%</span><span class="p">)))</span><span class="c1">; segment refers to rectangle&#39;s main diagonal</span>
<span class="p">(</span><span class="k">def </span><span class="nv">height</span> <span class="o">#</span><span class="p">(</span><span class="nf">diff</span> <span class="nv">y-point</span> <span class="p">(</span><span class="nf">start-segment</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">end-segment</span> <span class="nv">%</span><span class="p">)))</span>

<span class="c1">; Implementation 2</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">make-rectangle</span> <span class="p">[</span><span class="nv">p-topleft</span> <span class="nv">size</span><span class="p">]</span> <span class="p">(</span><span class="nb">list </span><span class="nv">p-topleft</span> <span class="nv">size</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">size-rectangle</span> <span class="p">[</span><span class="nv">rect</span><span class="p">]</span> <span class="p">(</span><span class="nb">second </span><span class="nv">rect</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">width</span> <span class="p">[</span><span class="nv">rect</span><span class="p">]</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">size-rectangle</span> <span class="nv">rect</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">height</span> <span class="p">[</span><span class="nv">rect</span><span class="p">]</span> <span class="p">(</span><span class="nb">second </span><span class="p">(</span><span class="nf">size-rectangle</span> <span class="nv">rect</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">perimeter</span> <span class="p">[</span><span class="nv">rect</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">width</span> <span class="nv">rect</span><span class="p">)</span> <span class="p">(</span><span class="nf">height</span> <span class="nv">rect</span><span class="p">))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">area</span> <span class="p">[</span><span class="nv">rect</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">width</span> <span class="nv">rect</span><span class="p">)</span> <span class="p">(</span><span class="nf">height</span> <span class="nv">rect</span><span class="p">)))</span>


</code></pre></div><h3 id="exercise-24">Exercise 2.4</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nb">cons </span><span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="o">#</span><span class="p">(</span><span class="nf">%</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">car</span> <span class="p">[</span><span class="nv">z</span><span class="p">]</span> <span class="p">(</span><span class="nf">z</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">p</span> <span class="nv">q</span><span class="p">]</span> <span class="nv">p</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="nf">car</span> <span class="o">#</span><span class="p">(</span><span class="nf">%</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nf">%</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">p</span> <span class="nv">q</span><span class="p">]</span> <span class="nv">p</span><span class="p">))</span><span class="c1">; =&gt;</span>
<span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">p</span> <span class="nv">q</span><span class="p">]</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span><span class="c1">; =&gt;</span>
<span class="nv">x</span> 

<span class="p">(</span><span class="kd">defn </span><span class="nv">cdr</span> <span class="p">[</span><span class="nv">z</span><span class="p">]</span> <span class="p">(</span><span class="nf">z</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">p</span> <span class="nv">q</span><span class="p">]</span> <span class="nv">q</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-25">Exercise 2.5</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nb">cons </span><span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">Math/pow</span> <span class="mi">2</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/pow</span> <span class="mi">3</span> <span class="nv">y</span><span class="p">))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">cdr</span> <span class="p">[</span><span class="nv">z</span><span class="p">]</span> 
  <span class="p">(</span><span class="kd">defn </span><span class="nv">iter</span> <span class="p">[</span><span class="nv">z</span> <span class="nv">result</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">z</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">z</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">result</span> <span class="mi">1</span><span class="p">))</span><span class="nv">result</span> <span class="p">))</span>
  <span class="p">(</span><span class="nf">iter</span> <span class="nv">z</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">car</span> <span class="p">[</span><span class="nv">z</span><span class="p">]</span> 
  <span class="p">(</span><span class="kd">defn </span><span class="nv">iter</span> <span class="p">[</span><span class="nv">z</span> <span class="nv">result</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">z</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">z</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">result</span> <span class="mi">1</span><span class="p">))</span><span class="nv">result</span> <span class="p">))</span>
  <span class="p">(</span><span class="nf">iter</span> <span class="nv">z</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-26">Exercise 2.6</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">add-1</span> <span class="nv">zero</span><span class="p">)</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">zero</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)))</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">one</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="nf">fn</span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))</span><span class="c1">; </span>

<span class="p">(</span><span class="nf">add-1</span> <span class="nv">one</span><span class="p">)</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">one</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">fn</span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">x</span><span class="p">))))</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))</span><span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">two</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">def </span><span class="nb">+ </span><span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-27">Exercise 2.7</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">lower-bound</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">upper-bound</span> <span class="nv">second</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-28">Exercise 2.8</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">sub-interval</span> <span class="p">[</span><span class="nv">I1</span> <span class="nv">I2</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">I1</span><span class="p">)</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">I2</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">I1</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">I2</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-29">Exercise 2.9</h3>
<p>For addition:</p>
<p>$$
(l_1, r_1) + (l_2, r_2) = (l_1 + l_2, r_1 + r_2)\newline
width_1 = r_1 - l_1\newline
width_2 = r_2 - l_2\newline
width_3 = (r_1+r_2)-(l_1+l_2)=width_1+width_2\newline
$$</p>
<p>For substraction:</p>
<p>$$
(l_1, r_1) - (l_2, r_2) = (l_1, r_1) + (-r_2, -l_2)\newline
$$</p>
<p>So this becomes addition.</p>
<p>For multiplication:</p>
<p>$$
(1, 2) \times (1, 2) = (1, 4)\newline
(1, 2) \times (3, 4) = (3, 8)
$$</p>
<p>All factors have width of 1, but their products' width are not the same.</p>
<p>For division:
$$
(1, 2) \div (1,2) = (\frac12, 2)\newline
(1, 2) \div (3, 4) = (\frac14, \frac23)
$$</p>
<p>All input intervals have width of 1, but their quotients' width are not the same.</p>
<h3 id="exercise-210">Exercise 2.10</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">div-interval</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Throwable.</span> <span class="s">&#34;Divded by a interval that spans 0&#34;</span><span class="p">)))</span>
   <span class="p">(</span><span class="nf">mul-interval</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">/ </span><span class="mf">1.0</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">/ </span><span class="mf">1.0</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">)))))</span>
</code></pre></div><h3 id="exercise-211">Exercise 2.11</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">mul-interval</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span> 
          <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">max </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)))</span>
                         <span class="p">(</span><span class="nb">max </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">y</span><span class="p">)))</span>
        <span class="ss">:else</span>
          <span class="p">(</span><span class="nf">mul-interval</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-212">Exercise 2.12</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">make-center-width</span> <span class="p">[</span><span class="nv">c</span> <span class="nv">w</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">make-interval</span> <span class="p">(</span><span class="nb">- </span><span class="nv">c</span> <span class="nv">w</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">c</span> <span class="nv">w</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">center</span> <span class="p">[</span><span class="nv">i</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">i</span><span class="p">)</span> 
        <span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">i</span><span class="p">))</span> 
     <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">width</span> <span class="p">[</span><span class="nv">i</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">upper-bound</span> <span class="nv">i</span><span class="p">)</span> 
        <span class="p">(</span><span class="nf">lower-bound</span> <span class="nv">i</span><span class="p">))</span> 
     <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-center-percent</span> <span class="p">[</span><span class="nv">c</span> <span class="nv">p</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-center-width</span> <span class="nv">c</span> <span class="p">(</span><span class="nb">* </span><span class="nv">c</span> <span class="nv">p</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">percent</span> <span class="p">[</span><span class="nv">I</span><span class="p">]</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">width</span> <span class="nv">I</span><span class="p">)</span>  <span class="p">(</span><span class="nf">center</span> <span class="nv">I</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-213">Exercise 2.13</h3>
<p>$$
I_1:= make-center-percent(c_1, p_1) (c_1 &gt; 0) \newline
I_2:= make-center-percent(c_2, p_2) (c_2 &gt; 0) \newline
\begin{aligned}
&amp;I_1 \times I_2 &amp;=&amp; (c_1(1 - p_1)c_2(1 - p_2), c_1 (1 + p_1) c_2 (1+p_2))&amp; \<br>
&amp;&amp;=&amp;(c_1c_2-(p_1 + p_2)c_1c_2+p_1p_2c_1c_2, c_1c_2+(p_1 + p_2)c_1c_2+p_1p_2c_1c_2)&amp;
\end{aligned} \newline
center(I_1 \times I_2) = c_1c_2 + p_1p_2c_1c_2 \newline
percent(I_1 \times I_2) = \frac{(p_1 + p_2)c_1c_2}{c_1c_2 + p_1p_2c_1c_2} \newline
\begin {aligned}
&amp; \because &amp;p_1 &laquo; 1, p_2 &laquo; 1 \<br>
&amp;\therefore &amp;center(I_1 \times I_2) &amp;\approx&amp; c_1 c_2 &amp; \<br>
&amp;&amp; percent(I_1 \times I_2) &amp;\approx&amp; p_1 + p_2 &amp;
\end {aligned}
$$</p>
<h3 id="exercise-214">Exercise 2.14</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">par1</span> <span class="p">[</span><span class="nv">r1</span> <span class="nv">r2</span><span class="p">]</span> <span class="p">(</span><span class="nf">div-interval</span> <span class="p">(</span><span class="nf">mul-interval</span> <span class="nv">r1</span> <span class="nv">r2</span><span class="p">)</span> <span class="p">(</span><span class="nf">add-interval</span> <span class="nv">r1</span> <span class="nv">r2</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">par2</span> <span class="p">[</span><span class="nv">r1</span> <span class="nv">r2</span><span class="p">]</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">one</span> <span class="p">(</span><span class="nf">make-interval</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)]</span> <span class="p">(</span><span class="nf">div-interval</span> <span class="nv">one</span> <span class="p">(</span><span class="nf">add-interval</span> <span class="p">(</span><span class="nf">div-interval</span> <span class="nv">one</span> <span class="nv">r1</span><span class="p">)</span> <span class="p">(</span><span class="nf">div-interval</span> <span class="nv">one</span> <span class="nv">r2</span><span class="p">)))))</span>
</code></pre></div><p>The error occurs because $A \div A = (1, 1)$ is not guaranteed in interval calculation.</p>
<h3 id="exercise-215">Exercise 2.15</h3>
<p>Yes, she is. Avoiding the same variable invloves into the calculation twice can help us avoid the occasion in Exercise 2.14.</p>
<h3 id="exercise-216">Exercise 2.16</h3>
<p>My first thought is that, programming is mostly engineering rather than theory.</p>
<p>Engineering is always bothered with the complexity of the real world, you should consider the comsumption of resources but in theory you don&rsquo;t.</p>
<p>For example, computer can only approximate e, but in theory you just pick a sign representing it. (Space is limited, however, the information needed to represent e is infinite. )</p>
<p>I don&rsquo;t think &ldquo;to design an interval-arithmetic package that does not have this shortcoming&rdquo; is possible.</p>
<p>As long as you use one name mutiple times to refers to some variant, the problem in 2.14 will happen.</p>
<h3 id="exercise-217">Exercise 2.17</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">last-pair</span> <span class="p">[</span><span class="nv">L</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="p">(</span><span class="nb">second </span><span class="nv">L</span><span class="p">))</span> <span class="nv">L</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">L</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-218">Exercise 2.18</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nb">reverse </span><span class="p">[</span><span class="nv">L</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">L</span><span class="p">)</span> <span class="nv">L</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nb">rest </span><span class="nv">L</span><span class="p">))</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">first </span><span class="nv">L</span><span class="p">)))))</span>  
</code></pre></div><h3 id="exercise-219">Exercise 2.19</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">no-more?</span> <span class="nv">empty?</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">first-denomination</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">except-first-denomination</span> <span class="nv">rest</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">us-coins</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">50</span> <span class="mi">25</span> <span class="mi">10</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">unordered-us-coins</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">25</span> <span class="mi">1</span> <span class="mi">50</span> <span class="mi">5</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">uk-coins</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">100</span> <span class="mi">50</span> <span class="mi">20</span> <span class="mi">10</span> <span class="mi">5</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mf">0.5</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">cc</span> <span class="p">(</span><span class="nf">memoize</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">amount</span> <span class="nv">coins-list</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">amount</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span>
        <span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">amount</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">no-more?</span> <span class="nv">coins-list</span><span class="p">))</span> <span class="mi">0</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">cc</span> <span class="nv">amount</span> <span class="p">(</span><span class="nf">except-first-denomination</span> <span class="nv">coins-list</span><span class="p">))</span>
                 <span class="p">(</span><span class="nf">cc</span> <span class="p">(</span><span class="nb">- </span><span class="nv">amount</span> <span class="p">(</span><span class="nf">first-denomination</span> <span class="nv">coins-list</span><span class="p">))</span> <span class="nv">coins-list</span><span class="p">))))))</span>
<span class="p">(</span><span class="nf">cc</span> <span class="mi">100</span> <span class="nv">us-coins</span><span class="p">)</span>
<span class="p">(</span><span class="nf">cc</span> <span class="mi">100</span> <span class="nv">unordered-us-coins</span><span class="p">)</span>
</code></pre></div><p>The order of the list coins-list doesn&rsquo;t affect the answer produced by cc.</p>
<p>This is because the order of the coins are irrelevant to the plans to change the money.</p>
<h3 id="exercise-220">Exercise 2.20</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">same-parity</span> <span class="p">[</span><span class="nv">a</span> <span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">a</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">b</span> <span class="p">(</span><span class="nb">first </span><span class="nv">args</span><span class="p">)]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="nb">- </span><span class="nv">b</span> <span class="nv">a</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">list </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">same-parity</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">args</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">apply </span><span class="nv">same-parity</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">args</span><span class="p">))))))</span>
</code></pre></div><h3 id="exercise-221">Exercise 2.21</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">square-list</span> <span class="p">[</span><span class="nv">items</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">items</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">first </span><span class="nv">items</span><span class="p">)]</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">a</span><span class="p">)))</span> <span class="p">(</span><span class="nf">square-list</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">items</span><span class="p">)))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">square-list</span> <span class="p">[</span><span class="nv">items</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">items</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-222">Exercise 2.22</h3>
<p>The function <code>cons</code> kept pushing elemnets to the front of the array.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">square</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">square-list</span> <span class="p">[</span><span class="nv">items</span><span class="p">]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">iter</span> <span class="p">[</span><span class="nv">things</span> <span class="nv">answer</span><span class="p">]</span> 
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">things</span><span class="p">)</span> <span class="nv">answer</span> 
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">things</span><span class="p">)</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">answer</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">first </span><span class="nv">things</span><span class="p">)))))))</span>
  <span class="p">(</span><span class="nf">iter</span> <span class="nv">items</span> <span class="o">&#39;</span><span class="p">()))</span>
</code></pre></div><p>This works for me&hellip; Maybe it&rsquo;s only because the call to iter in Scheme gives <code>nil</code> as the first element in the list.</p>
<h3 id="exercise-223">Exercise 2.23</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">for-each</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">col</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="nv">col</span><span class="p">)</span> <span class="nv">nil</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">for-each</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">col</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="nv">col</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">for-each</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">col</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">col</span><span class="p">))</span> <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">first </span><span class="nv">col</span><span class="p">))</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">col</span><span class="p">)))))</span>
</code></pre></div><h3 id="exercise-224">Exercise 2.24</h3>
<p>Result by the interpreter : (1 (2 (3 4)))</p>
<p>Graphs are omited.</p>
<h3 id="exercise-225">Exercise 2.25</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">-&gt; </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">))</span>
<span class="p">(</span><span class="nb">-&gt; </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">7</span><span class="p">))</span> <span class="p">(</span><span class="nf">first</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">))</span>
<span class="p">(</span><span class="nb">-&gt; </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="mi">2</span> <span class="p">(</span><span class="mi">3</span> <span class="p">(</span><span class="mi">4</span> <span class="p">(</span><span class="mi">5</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">7</span><span class="p">))))))</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest</span><span class="p">)</span> <span class="p">(</span><span class="nf">first</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-226">Exercise 2.26</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span>
<span class="p">(</span><span class="nb">concat </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">(</span><span class="nb">list </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-227">Exercise 2.27</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">deep-reverse</span> <span class="p">[</span><span class="nv">L</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">L</span><span class="p">)</span> <span class="nv">L</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nf">deep-reverse</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">L</span><span class="p">))</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">first </span><span class="nv">L</span><span class="p">)]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">deep-reverse</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">a</span><span class="p">))))))</span>  
</code></pre></div><h3 id="exercise-228">Exercise 2.28</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fringe</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">n</span><span class="p">)</span> 
    <span class="nv">n</span>
    <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">first </span><span class="nv">n</span><span class="p">)]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">fringe</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">a</span><span class="p">))</span> <span class="p">)</span> 
            <span class="p">(</span><span class="nf">fringe</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">n</span><span class="p">)))))</span> 
</code></pre></div><h3 id="exercise-229">Exercise 2.29</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">left-branch</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">right-branch</span> <span class="nv">second</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">length</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">structure</span> <span class="nv">second</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">total-weight</span> <span class="p">[</span><span class="nv">m</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">m</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">total-weight</span> <span class="p">(</span><span class="nf">structure</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">m</span><span class="p">)))</span> <span class="p">(</span><span class="nf">total-weight</span> <span class="p">(</span><span class="nf">structure</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">m</span><span class="p">))))</span> <span class="nv">m</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">balanced?</span>
  <span class="p">([</span><span class="nv">m</span><span class="p">]</span> <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">balanced?</span> <span class="nv">m</span> <span class="nv">true</span><span class="p">)))</span>
  <span class="p">([</span><span class="nv">m</span> <span class="nv">success</span><span class="p">]</span> 
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">m</span><span class="p">)</span> 
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">bl</span> <span class="p">(</span><span class="nf">balanced</span> <span class="p">(</span><span class="nf">structure</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">m</span><span class="p">)))</span> <span class="nv">br</span> <span class="p">(</span><span class="nf">balanced</span> <span class="p">(</span><span class="nf">structure</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">m</span><span class="p">)))]</span> 
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="nv">success</span> <span class="p">(</span><span class="nb">&gt;= </span><span class="nv">bl</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;= </span><span class="nv">br</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">* </span><span class="nv">bl</span> <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">m</span><span class="p">)))</span> <span class="p">(</span><span class="nb">* </span><span class="nv">br</span> <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">m</span><span class="p">)))))</span> 
          <span class="p">(</span><span class="nb">+ </span><span class="nv">bl</span> <span class="nv">br</span><span class="p">)</span> <span class="mi">-1</span><span class="p">))</span>
      <span class="nv">m</span><span class="p">)))</span> 
</code></pre></div><p>Only 4 functions, <code>left-branch</code>, <code>right-branch</code>, <code>length</code> and <code>structure</code>.</p>
<p>(Actually in the Clojure implementation there&rsquo;s nothing to change.</p>
<h3 id="exercise-230">Exercise 2.30</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">square-tree</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">square-tree</span> <span class="p">(</span><span class="nb">first </span><span class="nv">n</span><span class="p">))</span> <span class="p">(</span><span class="nf">square-tree</span> <span class="p">(</span><span class="nb">second </span><span class="nv">n</span><span class="p">)))</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="nv">n</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">square-tree</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">map </span><span class="nv">square-tree</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="nv">n</span><span class="p">)))</span>
</code></pre></div><p>The second implementation is better, since it can deal with non-binary trees.</p>
<h3 id="exercise-231">Exercise 2.31</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">tree-map</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">node?</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">tree-map</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-232">Exercise 2.32</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">subsets</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">s</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(())</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span><span class="o">&#39;</span> <span class="p">(</span><span class="nf">subsets</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">))</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">)]</span> 
      <span class="p">(</span><span class="nb">concat </span><span class="nv">s</span><span class="o">&#39;</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">conj </span><span class="nv">%</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">s</span><span class="o">&#39;</span><span class="p">)))))</span>
</code></pre></div><p>The application keeps reduce the size of a problem until it can be solve in constant time,</p>
<p>then merge the solutions of sub problems until we have the solution of the original problem.</p>
<h3 id="exercise-233">Exercise 2.33</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nb">map </span><span class="p">[</span><span class="nv">p</span> <span class="nv">sequence</span><span class="p">]</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">conj </span><span class="nv">%1</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">%2</span><span class="p">))</span> <span class="p">[]</span> <span class="nv">sequence</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">append</span> <span class="p">[</span><span class="nv">seq1</span> <span class="nv">seq2</span><span class="p">]</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">conj </span><span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="p">(</span><span class="nf">vec</span> <span class="nv">seq1</span><span class="p">)</span> <span class="nv">seq2</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">length</span> <span class="p">[</span><span class="nv">sequence</span><span class="p">]</span> <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">))</span> <span class="mi">0</span> <span class="nv">sequence</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-234">Exercise 2.34</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">horner-eval</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">Cs</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">cur</span> <span class="nv">C_i</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">cur</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">C_i</span><span class="p">))</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">Cs</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">horner-eval</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">0</span> <span class="mi">5</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-235">Exercise 2.35</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">count-leaves</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">reduce + </span><span class="mi">0</span> <span class="p">(</span><span class="nb">map </span><span class="nv">count-leaves</span> <span class="nv">n</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-236">Exercise 2.36</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">accumulate-n</span> <span class="p">[</span><span class="nv">op</span> <span class="nv">init</span> <span class="nv">seqs</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="p">(</span><span class="nb">first </span><span class="nv">seqs</span><span class="p">))</span> <span class="p">()</span>
    <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">accumulate-n</span> <span class="nv">op</span> <span class="nv">init</span> <span class="p">(</span><span class="nb">map rest </span><span class="nv">seqs</span><span class="p">))</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">op</span> <span class="nv">init</span> <span class="p">(</span><span class="nb">map first </span><span class="nv">seqs</span><span class="p">)))))</span>
</code></pre></div><h3 id="exercise-237">Exercise 2.37</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">dot-product</span> <span class="p">[</span><span class="nv">v</span> <span class="nv">w</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">reduce + </span><span class="mi">0</span> <span class="p">(</span><span class="nb">map * </span><span class="nv">v</span> <span class="nv">w</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">matrix-*-vector</span> <span class="p">[</span><span class="nv">m</span> <span class="nv">v</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">dot-product</span> <span class="nv">%</span> <span class="nv">v</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">transpose</span> <span class="p">[</span><span class="nv">m</span><span class="p">]</span> 
  <span class="p">(</span><span class="nf">accumulate-n</span> <span class="nb">conj </span><span class="p">[]</span> <span class="nv">m</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">matrix*matrix</span> <span class="p">[</span><span class="nv">m</span> <span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cols</span> <span class="p">(</span><span class="nf">transpose</span> <span class="nv">n</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">matrix-*-vector</span> <span class="nv">cols</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">m</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-238">Exercise 2.38</h3>
<p>Clojure only has fold-left, rather than fold-right.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="mi">1</span><span class="nv">/3</span>
<span class="mi">3</span><span class="nv">/2</span>
<span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="mi">2</span> <span class="p">(</span><span class="mi">3</span> <span class="nv">nil</span><span class="p">)))</span>
<span class="p">(((</span><span class="nf">nil</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><p>The result of <code>fold-left</code> and <code>fold-right</code> are the same if and only if the associative law works for the function f.</p>
<h3 id="exercise-239">Exercise 2.39</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">fold-left</span> <span class="nv">reduce</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">fold-right</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">init</span> <span class="nv">seq</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">seq</span><span class="p">)</span> <span class="nv">init</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">first </span><span class="nv">seq</span><span class="p">)</span> <span class="p">(</span><span class="nf">fold-right</span> <span class="nv">f</span> <span class="nv">init</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">seq</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nb">reverse </span><span class="p">[</span><span class="nv">seq</span><span class="p">]</span> <span class="p">(</span><span class="nf">fold-right</span> <span class="o">#</span><span class="p">(</span><span class="nb">conj </span><span class="nv">%2</span> <span class="nv">%1</span><span class="p">)</span> <span class="p">[]</span> <span class="nv">seq</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nb">reverse </span><span class="p">[</span><span class="nv">seq</span><span class="p">]</span> <span class="p">(</span><span class="nf">fold-left</span> <span class="o">#</span><span class="p">(</span><span class="nb">conj </span><span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()</span> <span class="nv">seq</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-240">Exercise 2.40</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">unique-pairs</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">mapcat </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">i</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">j</span><span class="p">]</span> <span class="p">(</span><span class="nb">list </span><span class="nv">i</span> <span class="nv">j</span><span class="p">))</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">prime?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">every? </span><span class="o">#</span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nf">mod</span> <span class="nv">x</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nf">Math/sqrt</span> <span class="nv">x</span><span class="p">))))))</span>


<span class="p">(</span><span class="kd">defn </span><span class="nv">prime-sum-pairs</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nf">prime?</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">first </span><span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nb">second </span><span class="nv">%</span><span class="p">)))</span> <span class="p">(</span><span class="nf">unique-pairs</span> <span class="nv">n</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-241">Exercise 2.41</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">triples-e</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">unique-pairs</span> <span class="nv">n</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">second </span><span class="nv">%</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">first </span><span class="nv">%</span><span class="p">)]</span> <span class="p">(</span><span class="nb">&lt; </span><span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>
       <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">second </span><span class="nv">%</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">first </span><span class="nv">%</span><span class="p">)]</span> <span class="p">(</span><span class="nb">list </span><span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">triples-le</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">3</span><span class="p">)</span> <span class="p">()</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nf">triples-le</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nf">triples-e</span> <span class="nv">n</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-242">Exercise 2.42</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">empty-board</span> <span class="p">())</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">safe?</span> <span class="p">[</span><span class="nv">k</span> <span class="nv">positions</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">row-k</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">positions</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">diagonal-k-1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">k</span> <span class="nv">row-k</span><span class="p">)</span> <span class="nv">diagonal-k-2</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="nv">row-k</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">every? </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">i</span><span class="p">]</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">row-i</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">positions</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">diagonal-i-1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="nv">row-i</span><span class="p">)</span> <span class="nv">diagonal-i-2</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="nv">row-i</span><span class="p">)]</span>
      <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">not= </span><span class="nv">row-i</span> <span class="nv">row-k</span><span class="p">)</span> <span class="p">(</span><span class="nb">not= </span><span class="nv">diagonal-i-1</span> <span class="nv">diagonal-k-1</span><span class="p">)</span> <span class="p">(</span><span class="nb">not= </span><span class="nv">diagonal-i-2</span> <span class="nv">diagonal-k-2</span><span class="p">))))</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="nv">k</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">adjoin-position</span> <span class="p">[</span><span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">concat </span><span class="nv">rest-of-queens</span> <span class="p">(</span><span class="nb">list </span><span class="nv">new-row</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">queens</span> <span class="p">[</span><span class="nv">board-size</span><span class="p">]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">queen-cols</span> <span class="p">[</span><span class="nv">k</span><span class="p">]</span> 
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">empty-board</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">queen-cols</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">))</span>
                     <span class="p">(</span><span class="nb">mapcat </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">rest-of-queens</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">new-row</span><span class="p">]</span> <span class="p">(</span><span class="nf">adjoin-position</span> <span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">))</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">board-size</span> <span class="mi">1</span><span class="p">)))))</span>
                     <span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nb">partial </span><span class="nv">safe?</span> <span class="nv">k</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">queen-cols</span> <span class="nv">board-size</span><span class="p">))</span>
</code></pre></div><p>Another version (the search algorithm), works in the positive order.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure">    
<span class="p">(</span><span class="kd">defn </span><span class="nv">queens-optimized</span> <span class="p">[</span><span class="nv">board-size</span><span class="p">]</span> 
  <span class="p">(</span><span class="kd">defn </span><span class="nv">safe?</span> <span class="p">[</span><span class="nv">used-diagonal-1</span> <span class="nv">used-diagonal-2</span> <span class="nv">cur</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">new-row</span> <span class="p">(</span><span class="nb">last </span><span class="nv">cur</span><span class="p">)</span> <span class="nv">new-col</span> <span class="p">(</span><span class="nb">count </span><span class="nv">cur</span><span class="p">)]</span>
      <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">used-diagonal-1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-row</span> <span class="nv">new-col</span> <span class="mi">-2</span><span class="p">))</span> <span class="p">(</span><span class="nf">used-diagonal-2</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-row</span> <span class="p">(</span><span class="nb">- </span><span class="nv">new-col</span><span class="p">)</span> <span class="nv">board-size</span> <span class="mi">-1</span><span class="p">))))))</span>

  <span class="c1">; used-diagonal-1: [0, 2n-2],  used-diagonal-2: [0, 2n-2], unused: [1, n]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">generate-state</span> <span class="p">[</span><span class="nv">used-diagonal-1</span> <span class="nv">used-diagonal-2</span> <span class="nv">unused</span> <span class="nv">cur</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">new-row</span> <span class="p">(</span><span class="nb">last </span><span class="nv">cur</span><span class="p">)</span> <span class="nv">new-col</span> <span class="p">(</span><span class="nb">count </span><span class="nv">cur</span><span class="p">)]</span>
      <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">used-diagonal-1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-row</span> <span class="nv">new-col</span> <span class="mi">-2</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">assoc </span><span class="nv">used-diagonal-2</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-row</span> <span class="p">(</span><span class="nb">- </span><span class="nv">new-col</span><span class="p">)</span> <span class="nv">board-size</span> <span class="mi">-1</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">disj </span><span class="nv">unused</span> <span class="nv">new-row</span><span class="p">)</span>
            <span class="nv">cur</span><span class="p">)))</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">permutation</span> <span class="p">[</span><span class="nv">used-diagonal-1</span> <span class="nv">used-diagonal-2</span> <span class="nv">unused</span> <span class="nv">cur</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">unused</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">cur</span><span class="p">)</span>
                        <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">unused</span>
                             <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">conj </span><span class="nv">cur</span> <span class="nv">%</span><span class="p">))</span> 
                             <span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nb">partial </span><span class="nv">safe?</span> <span class="nv">used-diagonal-1</span> <span class="nv">used-diagonal-2</span><span class="p">))</span>
                             <span class="p">(</span><span class="nb">mapcat </span><span class="o">#</span><span class="p">(</span><span class="nb">apply </span><span class="nv">permutation</span> <span class="p">(</span><span class="nf">generate-state</span> <span class="nv">used-diagonal-1</span> <span class="nv">used-diagonal-2</span> <span class="nv">unused</span> <span class="nv">%</span><span class="p">)))</span>
                        <span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">initial-diagonal</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">board-size</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">false</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">permutation</span> <span class="nv">initial-diagonal</span> <span class="nv">initial-diagonal</span> <span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">board-size</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">[])))</span>
</code></pre></div><p>It&rsquo;s slower because:</p>
<ol>
<li>
<p>The search algorithm wants the state to be transfered between function calls.</p>
</li>
<li>
<p>The search algorithm forms a tree of call stacks, while the recursive algorithm only forms a chain of call stacks.</p>
</li>
</ol>
<p>So here you mihght see that pure recursive algorithm works better for this particular problem.</p>
<h3 id="exercise-243">Exercise 2.43</h3>
<p>Interchanging the order of maping cause the call stacks form a tree, i.e. every <code>queen-cols</code> functions calls itself at least once(In the beginning it&rsquo;s n times.</p>
<p>Estimates:
$$
\begin {aligned}
&amp;\because&amp; \sum_{i=4}^n \frac{i^2}{i(i-1)(i-2)(i-3)} \text{ converges.}\<br>
&amp;\therefore&amp; T(n)=O( \sum_{i=1}^n i^2 \frac {n!}{i!}) = O(n!\sum_{i=4}^n \frac{i^2}{i(i-1)(i-2)(i-3)}) = O(n!)\<br>
&amp;&amp;T'(n)=f(n)\text{, where }f(i) = O(n f(i-1)), f(0) = O(1) \<br>
&amp;&amp;T'(n)=O(n^n) \<br>
\end{aligned}
$$</p>
<p>Calculating the actual time difference its meaningless most of the time, since there is always a constant factor in <a href="https://en.wikipedia.org/wiki/Big_O_notation" target="_blank" rel="noopener noreferrer">Big O notation</a>.</p>
<p>(Also I&rsquo;m lazy :p)</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">empty-board</span> <span class="p">())</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">safe?</span> <span class="p">[</span><span class="nv">k</span> <span class="nv">positions</span><span class="p">]</span>
      <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">not= </span><span class="nv">row-i</span> <span class="nv">row-k</span><span class="p">)</span> <span class="p">(</span><span class="nb">not= </span><span class="nv">diagonal-i-1</span> <span class="nv">diagonal-k-1</span><span class="p">)</span> <span class="p">(</span><span class="nb">not= </span><span class="nv">diagonal-i-2</span> <span class="nv">diagonal-k-2</span><span class="p">))))</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="nv">k</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">adjoin-position</span> <span class="p">[</span><span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">concat </span><span class="nv">rest-of-queens</span> <span class="p">(</span><span class="nb">list </span><span class="nv">new-row</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">queens</span> <span class="p">[</span><span class="nv">board-size</span><span class="p">]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">queen-cols</span> <span class="p">[</span><span class="nv">k</span><span class="p">]</span> 
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">empty-board</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">queen-cols</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">))</span>
                     <span class="p">(</span><span class="nb">mapcat </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">rest-of-queens</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">new-row</span><span class="p">]</span> <span class="p">(</span><span class="nf">adjoin-position</span> <span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">))</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">board-size</span> <span class="mi">1</span><span class="p">)))))</span>
                     <span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nb">partial </span><span class="nv">safe?</span> <span class="nv">k</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">queen-cols</span> <span class="nv">board-size</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">bad-queens</span> <span class="p">[</span><span class="nv">board-size</span><span class="p">]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">queen-cols</span> <span class="p">[</span><span class="nv">k</span><span class="p">]</span> 
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">empty-board</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">board-size</span> <span class="mi">1</span><span class="p">))</span>
                     <span class="p">(</span><span class="nb">mapcat </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">new-row</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">rest-of-queens</span><span class="p">]</span> <span class="p">(</span><span class="nf">adjoin-position</span> <span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">))</span> <span class="p">(</span><span class="nf">queen-cols</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">)))))</span>
                     <span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nb">partial </span><span class="nv">safe?</span> <span class="nv">k</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">queen-cols</span> <span class="nv">board-size</span><span class="p">))</span>

<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">queens</span> <span class="mi">8</span><span class="p">))</span><span class="c1">; &#34;Elapsed time: 18.970709 msecs&#34;</span>
<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">bad-queens</span> <span class="mi">8</span><span class="p">))</span><span class="c1">; &#34;Elapsed time: 2977.498625 msecs&#34;</span>
</code></pre></div><h3 id="exercise-244">Exercise 2.44</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">up-split</span> <span class="p">[</span><span class="nv">painter</span> <span class="nv">n</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">painter</span> 
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">smaller</span> <span class="p">(</span><span class="nf">up-split</span> <span class="nv">painter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))]</span>
      <span class="p">(</span><span class="nf">below</span> <span class="nv">painter</span> <span class="p">(</span><span class="nf">beside</span> <span class="nv">smaller</span> <span class="nv">smaller</span><span class="p">)))))</span>
</code></pre></div><h3 id="exercise-245">Exercise 2.45</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">split</span> <span class="p">[</span><span class="nv">painter</span> <span class="nv">n</span> <span class="nv">op1</span> <span class="nv">op2</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">painter</span> 
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">smaller</span> <span class="p">(</span><span class="nf">split</span> <span class="nv">painter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">op1</span> <span class="nv">op2</span><span class="p">)]</span>
      <span class="p">(</span><span class="nf">op1</span> <span class="nv">painter</span> <span class="p">(</span><span class="nf">op2</span> <span class="nv">smaller</span> <span class="nv">smaller</span><span class="p">)))))</span>
      
<span class="p">(</span><span class="k">def </span><span class="nv">right-split</span> <span class="nv">beside</span> <span class="nv">below</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">up-split</span> <span class="nv">below</span> <span class="nv">beside</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-246">Exercise 2.46</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">make-vect</span> <span class="nv">vector</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">xcor-vect</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">ycor-vect</span> <span class="nv">second</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">add-vect</span> <span class="p">[</span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v2</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v2</span><span class="p">))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">sub-vect</span> <span class="p">[</span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v2</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v2</span><span class="p">))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">scale-vect</span> <span class="p">[</span><span class="nv">s</span> <span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">* </span><span class="nv">s</span> <span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="nv">s</span> <span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-247">Exercise 2.47</h3>
<p>Clojure doesn&rsquo;t have the same <code>cons</code> as Scheme does.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">make-frame</span> <span class="p">[</span><span class="nv">origin</span> <span class="nv">edge1</span> <span class="nv">edge2</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">list </span><span class="nv">origin</span> <span class="nv">edge1</span> <span class="nv">edge2</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">origin-frame</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">edge1-frame</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">edge2-frame</span> <span class="nv">last</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-248">Exercise 2.48</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">make-segment</span> <span class="nv">list</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">start-segment</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">end-segment</span> <span class="nv">second</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-249">Exercise 2.49</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">frame-coord-map</span> <span class="p">[</span><span class="nv">frame</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nf">add-vect</span> <span class="p">(</span><span class="nf">origin-frame</span> <span class="nv">frame</span><span class="p">)</span> 
          <span class="p">(</span><span class="nf">add-vect</span> <span class="p">(</span><span class="nf">scale-vect</span> <span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="nf">edge1-frame</span> <span class="nv">frame</span><span class="p">))</span>
                    <span class="p">(</span><span class="nf">scale-vect</span> <span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="nf">edge2-frame</span> <span class="nv">frame</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">segments-&gt;painter</span> <span class="p">[</span><span class="nv">segments</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">frame</span><span class="p">]</span> 
    <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">segment</span> <span class="nv">segments</span><span class="p">]</span>
      <span class="p">(</span><span class="nf">draw-line</span> <span class="p">((</span><span class="nf">frame-coord-map</span> <span class="nv">frame</span><span class="p">)</span> <span class="p">(</span><span class="nf">start-segment</span> <span class="nv">segment</span><span class="p">))</span> <span class="p">((</span><span class="nf">frame-coord-map</span> <span class="nv">frame</span><span class="p">)</span> <span class="p">(</span><span class="nf">end-segment</span> <span class="nv">segment</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">shape</span> <span class="p">[</span><span class="nv">point-list</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cnt</span> <span class="p">(</span><span class="nb">count </span><span class="nv">point-list</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">point-list</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">point-list</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">cnt</span><span class="p">)))</span> <span class="p">(</span><span class="nb">range </span><span class="nv">cnt</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">comp-painter</span> <span class="p">[</span><span class="nv">painters</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">frame</span><span class="p">]</span> <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">p</span> <span class="nv">painters</span><span class="p">]</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">frame</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">outline</span> <span class="p">(</span><span class="nf">shape</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">X</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">diamond</span> <span class="p">(</span><span class="nf">shape</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span><span class="nv">/2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span><span class="nv">/2</span> <span class="mi">0</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">wave</span> <span class="p">(</span><span class="nf">shape</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">apply </span><span class="nv">make-vect</span> <span class="nv">%</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span>
  <span class="p">(</span><span class="mi">1</span><span class="nv">/3</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="nv">/3</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">11</span><span class="nv">/14</span> <span class="mi">5</span><span class="nv">/6</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="nv">/3</span> <span class="mi">2</span><span class="nv">/3</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="nv">/3</span> <span class="mi">7</span><span class="nv">/12</span><span class="p">)</span> <span class="p">(</span><span class="mi">11</span><span class="nv">/14</span> <span class="mi">7</span><span class="nv">/12</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="nv">/12</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="nv">/3</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="nv">/3</span> <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="nv">/3</span> <span class="mi">1</span><span class="nv">/3</span><span class="p">)</span> <span class="p">(</span><span class="mi">11</span><span class="nv">/14</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="nv">/3</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="nv">/2</span> <span class="mi">1</span><span class="nv">/4</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="nv">/3</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="nv">/3</span> <span class="mi">5</span><span class="nv">/12</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="nv">/28</span> <span class="mi">1</span><span class="nv">/3</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">2</span><span class="nv">/3</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">5</span><span class="nv">/6</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="nv">/28</span> <span class="mi">7</span><span class="nv">/12</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="nv">/3</span> <span class="mi">2</span><span class="nv">/3</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="nv">/14</span> <span class="mi">5</span><span class="nv">/6</span><span class="p">)</span>
<span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">smile</span> <span class="p">(</span><span class="nf">shape</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-vect</span> <span class="mi">5</span><span class="nv">/12</span> <span class="mi">5</span><span class="nv">/6</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span><span class="nv">/2</span> <span class="mi">3</span><span class="nv">/4</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">7</span><span class="nv">/12</span> <span class="mi">5</span><span class="nv">/6</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">figures</span> <span class="p">{</span><span class="ss">:outline</span> <span class="nv">outline</span>, <span class="ss">:X</span> <span class="nv">X</span>, <span class="ss">:diamond</span> <span class="nv">diamond</span> <span class="ss">:wave</span> <span class="nv">wave</span> <span class="ss">:smile</span> <span class="nv">smile</span><span class="p">})</span>
<span class="p">(</span><span class="k">def </span><span class="nv">painter-figures</span> <span class="p">(</span><span class="nb">into </span><span class="p">{}</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">vector </span><span class="p">(</span><span class="nb">first </span><span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">segments-&gt;painter</span> <span class="p">(</span><span class="nb">second </span><span class="nv">%</span><span class="p">)))</span> <span class="nv">figures</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-250">Exercise 2.50</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">flip-horiz</span> <span class="p">[</span><span class="nv">painter</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">rotate90</span> <span class="p">[</span><span class="nv">painter</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">rotate180</span> <span class="p">[</span><span class="nv">painter</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-251">Exercise 2.51</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">rotate90</span> <span class="p">[</span><span class="nv">painter</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">beside</span> 
  <span class="p">([</span><span class="nv">painter</span><span class="p">]</span> <span class="p">(</span><span class="nf">beside</span> <span class="nv">painter</span> <span class="nv">painter</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">painter1</span> <span class="nv">painter2</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">split-point</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span><span class="nv">/2</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nv">paint-left</span> <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter1</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">split-point</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nv">paint-right</span> <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter2</span> <span class="nv">split-point</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span><span class="nv">/2</span> <span class="mi">1</span><span class="p">))]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">frame</span><span class="p">]</span> <span class="p">(</span><span class="nf">paint-left</span> <span class="nv">frame</span><span class="p">)</span> <span class="p">(</span><span class="nf">paint-right</span> <span class="nv">frame</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">below</span> 
  <span class="p">([</span><span class="nv">painter</span><span class="p">]</span> <span class="p">(</span><span class="nf">below</span> <span class="nv">painter</span> <span class="nv">painter</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">painter1</span> <span class="nv">painter2</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">split-point</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span>
        <span class="nv">paint-up</span> <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter1</span> <span class="nv">split-point</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nv">paint-down</span> <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter2</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">split-point</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">frame</span><span class="p">]</span> <span class="p">(</span><span class="nf">paint-up</span> <span class="nv">frame</span><span class="p">)</span> <span class="p">(</span><span class="nf">paint-down</span> <span class="nv">frame</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">below2</span> <span class="p">[</span><span class="nv">painter1</span> <span class="nv">painter2</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">rotate270</span> <span class="p">(</span><span class="nf">beside</span> <span class="p">(</span><span class="nf">rotate90</span> <span class="nv">painter1</span><span class="p">)</span> <span class="p">(</span><span class="nf">rotate90</span> <span class="nv">painter2</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-252">Exercise 2.52</h3>
<p>I use quil on clojure to implement everything of Chapter 2.2.4 on <a href="https://github.com/glyh/sicp-solutions-clojure/blob/main/src/sicp_solutions_clojure/chapter_2/picture_language.clj" target="_blank" rel="noopener noreferrer">Github</a>.</p>
<h3 id="exercise-253">Exercise 2.53</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span><span class="c1">; =&gt; (a b c)</span>
<span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;george</span><span class="p">))</span><span class="c1">; =&gt; ((george))</span>
<span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">x1</span> <span class="nv">x2</span><span class="p">)</span> <span class="p">(</span><span class="nf">y1</span> <span class="nv">y2</span><span class="p">)))</span><span class="c1">; =&gt; (y1 y2)</span>
<span class="p">(</span><span class="nf">cadr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">x1</span> <span class="nv">x2</span><span class="p">)</span> <span class="p">(</span><span class="nf">y1</span> <span class="nv">y2</span><span class="p">)))</span><span class="c1">; =&gt; y1</span>
<span class="p">(</span><span class="nf">pair?</span> <span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">a</span> <span class="nb">short </span><span class="nv">list</span><span class="p">)))</span><span class="c1">; =&gt; false</span>
<span class="p">(</span><span class="nf">memq</span> <span class="ss">&#39;red</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">red</span> <span class="nv">shoes</span><span class="p">)</span> <span class="p">(</span><span class="nf">blue</span> <span class="nv">socks</span><span class="p">)))</span><span class="c1">; =&gt; false</span>
<span class="p">(</span><span class="nf">memq</span> <span class="ss">&#39;red</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">red</span> <span class="nv">shoes</span> <span class="nv">blue</span> <span class="nv">socks</span><span class="p">))</span><span class="c1">; =&gt; true</span>
</code></pre></div><h3 id="exercise-254">Exercise 2.54</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">equal-list</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">list?</span> <span class="nv">b</span><span class="p">))</span> 
          <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">b</span><span class="p">))</span> <span class="nv">true</span>
                <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">b</span><span class="p">)))</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">equal-list</span> <span class="p">(</span><span class="nb">first </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">b</span><span class="p">))</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">b</span><span class="p">)))</span>
                <span class="ss">:else</span> <span class="nv">false</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">list?</span> <span class="nv">b</span><span class="p">)))</span> <span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="ss">:else</span> <span class="nv">false</span><span class="p">))</span>
</code></pre></div><p>Actually a single <code>=</code> will do all the jobs for us.</p>
<h3 id="exercise-255">Exercise 2.55</h3>
<p><code>'</code> is but a macro. The reader of clojure will translate <code>''abracadabra</code> into <code>(quote (quote abracadabra))</code>.</p>
<p>As a result, you&rsquo;ll get <code>(quote abracadabra)</code>.</p>
<h3 id="exercise-256">Exercise 2.56</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">variable?</span> <span class="nv">symbol?</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">same-variable?</span> <span class="nv">=</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-sum</span> <span class="p">[</span><span class="nv">a1</span> <span class="nv">a2</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">a1</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a2</span> 
        <span class="p">(</span><span class="nb">= </span><span class="nv">a2</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a1</span>
        <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nf">number?</span> <span class="nv">a2</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;+</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-product</span> <span class="p">[</span><span class="nv">a1</span> <span class="nv">a2</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">a1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">a2</span> <span class="mi">0</span><span class="p">))</span> <span class="mi">0</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">a1</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">a2</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">a2</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">a1</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;*</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-exponentiation</span> <span class="p">[</span><span class="nv">u</span> <span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">u</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">1</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">u</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;**</span> <span class="nv">u</span> <span class="nv">n</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">addend</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">augend</span> <span class="nv">last</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">multiplier</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">multiplicand</span> <span class="nv">last</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">base</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">exponent</span> <span class="nv">last</span><span class="p">)</span>


<span class="p">(</span><span class="kd">defn </span><span class="nv">sum?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;+</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">product?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;*</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">exponentiation?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;**</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">deriv</span> <span class="p">[</span><span class="nv">exp</span> <span class="nv">var</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">exp</span><span class="p">)</span> <span class="mi">0</span>
        <span class="p">(</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">sum?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">addend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">augend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">product?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">exponentiation?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-exponentiation</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span> <span class="mi">-1</span><span class="p">)))</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
         <span class="ss">:else</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Exception.</span> <span class="p">(</span><span class="nb">str </span><span class="s">&#34;unknown expression type: DERIV&#34;</span> <span class="nv">exp</span><span class="p">)))))</span>
</code></pre></div><h3 id="exercise-257">Exercise 2.57</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">variable?</span> <span class="nv">symbol?</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">same-variable?</span> <span class="nv">=</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-sum</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span> 
  <span class="p">(</span><span class="kd">defn </span><span class="nv">insert-into-sum</span> <span class="p">[</span><span class="nv">col</span> <span class="nv">i</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">col</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">first </span><span class="nv">col</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>
          <span class="ss">:else</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">col</span> <span class="nv">i</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">simplified</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">insert-into-sum</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="nv">args</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">simplified</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">simplified</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">simplified</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">simplified</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="nb">second </span><span class="nv">simplified</span><span class="p">)</span>
          <span class="ss">:else</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="o">&#39;</span><span class="p">[</span><span class="nv">+</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">simplified</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">simplified</span><span class="p">)</span> <span class="nv">simplified</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-product</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">insert-into-product</span> <span class="p">[</span><span class="nv">col</span> <span class="nv">i</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">col</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">first </span><span class="nv">col</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>
          <span class="ss">:else</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">col</span> <span class="nv">i</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="nv">%</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">args</span><span class="p">)</span> <span class="mi">0</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">simplified</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">insert-into-product</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="nv">args</span><span class="p">)]</span>
      <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">simplified</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">simplified</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">simplified</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">simplified</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nb">second </span><span class="nv">simplified</span><span class="p">)</span>
            <span class="ss">:else</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="o">&#39;</span><span class="p">[</span><span class="nv">*</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">simplified</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">simplified</span><span class="p">)</span> <span class="nv">simplified</span><span class="p">)))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-exponentiation</span> <span class="p">[</span><span class="nv">u</span> <span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">u</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">1</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">u</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">vector </span><span class="ss">&#39;**</span> <span class="nv">u</span> <span class="nv">n</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">base</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">exponent</span> <span class="nv">last</span><span class="p">)</span>


<span class="p">(</span><span class="kd">defn </span><span class="nv">sum?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;+</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">product?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;*</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">exponentiation?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">list?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;**</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">deriv-nth-product</span> <span class="p">[</span><span class="nv">col</span> <span class="k">var </span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply </span><span class="nv">make-product</span> <span class="p">(</span><span class="nf">map-indexed</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">id</span><span class="o">&#39;</span> <span class="nv">item</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">id</span><span class="o">&#39;</span> <span class="nv">id</span><span class="p">)</span> <span class="p">(</span><span class="nf">deriv</span> <span class="nv">item</span> <span class="nv">var</span><span class="p">)</span> <span class="nv">item</span><span class="p">))</span> <span class="nv">col</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">deriv</span> <span class="p">[</span><span class="nv">exp</span> <span class="nv">var</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">exp</span><span class="p">)</span> <span class="mi">0</span>
        <span class="p">(</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">sum?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">make-sum</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">deriv</span> <span class="nv">%</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">exp</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">product?</span> <span class="nv">exp</span><span class="p">)</span> 
          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">n</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">apply </span><span class="nv">make-sum</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">deriv-nth-product</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))))</span>
        <span class="p">(</span><span class="nf">exponentiation?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-exponentiation</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span> <span class="mi">-1</span><span class="p">)))</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
         <span class="ss">:else</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Exception.</span> <span class="p">(</span><span class="nb">str </span><span class="s">&#34;unknown expression type: DERIV&#34;</span> <span class="nv">exp</span><span class="p">)))))</span>

</code></pre></div><p>I&rsquo;ve changed the definition of <code>deriv</code> here.</p>
<p>You can also do it without changing the definition of <code>deriv</code>, just change <code>augend</code> and <code>multiplicand</code> to these:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">drop-nth</span> <span class="p">[</span><span class="nv">n</span> <span class="nv">coll</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">keep-indexed</span> <span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not= </span><span class="nv">%1</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">%2</span><span class="p">)</span> <span class="nv">coll</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">augend</span> <span class="p">[</span><span class="nv">exp</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">drop-nth</span> <span class="mi">1</span> <span class="nv">exp</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">multiplicand</span> <span class="p">[</span><span class="nv">exp</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">drop-nth</span> <span class="mi">1</span> <span class="nv">exp</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-258">Exercise 2.58</h3>
<h4 id="1">1)</h4>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">infix-&gt;prefix</span> <span class="p">[</span><span class="nv">exp</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">))</span> <span class="nv">exp</span>
    <span class="p">(</span><span class="nb">vector </span><span class="p">(</span><span class="nb">second </span><span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">infix-&gt;prefix</span> <span class="p">(</span><span class="nb">first </span><span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nf">infix-&gt;prefix</span> <span class="p">(</span><span class="nb">last </span><span class="nv">exp</span><span class="p">)))))</span>
</code></pre></div><h4 id="2">2)</h4>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">operators-precedence</span> <span class="p">{</span><span class="ss">&#39;+</span> <span class="mi">1</span>, <span class="ss">&#39;*</span> <span class="mi">2</span>, <span class="ss">&#39;**</span> <span class="mi">3</span><span class="p">})</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">add-parentheses-to-prefix</span> <span class="p">[</span><span class="nv">exp</span><span class="p">]</span> <span class="c1">; Only works for binary operators</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">))</span> <span class="nv">exp</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">sorted-ops</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">exp</span>
         <span class="p">(</span><span class="nf">map-indexed</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">idx</span> <span class="nv">itm</span><span class="p">]</span> <span class="p">(</span><span class="nb">list </span><span class="nv">idx</span> <span class="p">(</span><span class="nb">get </span><span class="nv">operators-precedence</span> <span class="nv">itm</span><span class="p">))))</span>
         <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nb">second </span><span class="nv">%</span><span class="p">)</span> <span class="nv">nil</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">sort-by </span><span class="nv">second</span><span class="p">))</span> <span class="nb">split-at </span><span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">first </span><span class="nv">sorted-ops</span><span class="p">))]</span> 
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">split-at</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">first </span><span class="nv">exp</span><span class="p">))</span><span class="c1">; the expression is a constant in some brackets</span>
        <span class="p">(</span><span class="nb">vector </span><span class="p">(</span><span class="nb">nth </span><span class="nv">exp</span> <span class="nv">split-at</span><span class="p">)</span> <span class="p">(</span><span class="nf">add-parentheses-to-prefix</span> <span class="p">(</span><span class="nb">take split-at </span><span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nf">add-parentheses-to-prefix</span> <span class="p">(</span><span class="nb">drop </span><span class="p">(</span><span class="nb">+ split-at </span><span class="mi">1</span><span class="p">)</span> <span class="nv">exp</span><span class="p">)))))))</span>
</code></pre></div><h3 id="exercise-259">Exercise 2.59</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">element-of-set?</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">set</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">first </span><span class="nv">set</span><span class="p">))</span> <span class="nv">true</span>
      <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">set</span><span class="p">))</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">set</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">adjoin-set</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">set</span><span class="p">]</span> 
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">element-of-set?</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span> <span class="nb">set </span><span class="p">(</span><span class="nb">conj set </span><span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">union-set</span> <span class="p">[</span><span class="nv">s1</span> <span class="nv">s2</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span> 
        <span class="p">(</span><span class="nf">empty?</span> <span class="nv">s2</span><span class="p">)</span> <span class="nv">s1</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nf">adjoin-set</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-260">Exercise 2.60</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">element-of-set?</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">set</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">first </span><span class="nv">set</span><span class="p">))</span> <span class="nv">true</span>
      <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">set</span><span class="p">))</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">set</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">ajoin-set</span> <span class="nv">conj</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">union-set</span> <span class="nv">concat</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">intersection-set</span> <span class="p">[</span><span class="nv">s1</span> <span class="nv">s2</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">s2</span><span class="p">))</span> <span class="p">()</span>
        <span class="p">(</span><span class="nf">element-of-set?</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span><span class="p">)</span> <span class="p">(</span><span class="nf">adjoin-set</span> <span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span><span class="p">)))</span>
</code></pre></div><p>For no/n-duplicate implementation:</p>
<p>$$
\begin{aligned}
\text{element-of-set: }&amp; \Theta(n)\<br>
\text{adjoin-set: }&amp; \Theta(n)\<br>
\text{union-set: }&amp; \Theta(n^2)\<br>
\text{intersection-set: }&amp; \Theta(n^2)\<br>
\end{aligned}
$$</p>
<p>For duplicate implementation:</p>
<p>$$
\begin{aligned}
\text{element-of-set: }&amp; \Theta(n)\<br>
\text{adjoin-set: }&amp; \Theta(1)\<br>
\text{union-set: }&amp; \Theta(n)\<br>
\text{intersection-set: }&amp; \Theta(n)\<br>
\end{aligned}
$$</p>
<p>Actually, I won&rsquo;t use the duplicate implementation in application&hellip; Why not just use <code>list</code> or <code>vector</code>?</p>
<h3 id="exercise-261">Exercise 2.61</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">element-of-set?</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">set</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">set</span><span class="p">)</span> <span class="nv">false</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">first </span><span class="nv">set</span><span class="p">))</span> <span class="nv">true</span>
        <span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="p">(</span><span class="nb">first </span><span class="nv">set</span><span class="p">))</span> <span class="nv">false</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">set</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">adjoin-set</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">set</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">set</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">first </span><span class="nv">set</span><span class="p">))</span> <span class="nv">set</span>
        <span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="p">(</span><span class="nb">first </span><span class="nv">set</span><span class="p">))</span> <span class="p">(</span><span class="nb">conj set </span><span class="nv">x</span><span class="p">)</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">set</span><span class="p">))</span> <span class="p">(</span><span class="nb">first </span><span class="nv">set</span><span class="p">))))</span>
</code></pre></div><p>This algorithm can be optimized to $O(\log n)$ with Dichotomic Search.</p>
<h3 id="exercise-262">Exercise 2.62</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">union-set</span> <span class="p">[</span><span class="nv">s1</span> <span class="nv">s2</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">s2</span><span class="p">)</span> <span class="nv">s1</span>
        <span class="p">(</span><span class="nf">empty?</span> <span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span>
        <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s2</span><span class="p">))</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s2</span><span class="p">))</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s2</span><span class="p">))</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">s1</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s2</span><span class="p">))</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s2</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-263">Exercise 2.63</h3>
<h4 id="1-1">1)</h4>
<p>Yes, they do.</p>
<h4 id="2-1">2)</h4>
<p><code>append</code> costs $O(n)$ in Scheme, while <code>cons</code> costs $O(1)$ in Scheme.</p>
<p>As a result, <code>tree-&gt;list-1</code> is $O(n^2)$, while <code>tree-&gt;list-2</code> is $O(n)$.</p>
<h3 id="exercise-264">Exercise 2.64</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">list-&gt;tree</span> <span class="p">[</span><span class="nv">elements</span><span class="p">]</span> 
  <span class="p">(</span><span class="kd">defn </span><span class="nv">partial-tree</span> <span class="p">[</span><span class="nv">elts</span> <span class="nv">n</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">nil</span> <span class="nv">elts</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">left-size</span> <span class="p">(</span><span class="nb">quot </span><span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="nv">right-size</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="nv">left-size</span> <span class="mi">1</span><span class="p">)</span> 
            <span class="p">[</span><span class="nv">left-tree</span> <span class="nv">non-left-elts</span><span class="p">]</span> <span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">elts</span> <span class="nv">left-size</span><span class="p">)</span> 
            <span class="p">[</span><span class="nv">cur</span> <span class="o">&amp;</span> <span class="nv">right-elts</span><span class="p">]</span> <span class="nv">non-left-elts</span>
            <span class="p">[</span><span class="nv">right-tree</span> <span class="nv">left-elts</span><span class="p">]</span> <span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">right-elts</span> <span class="nv">right-size</span><span class="p">)]</span>
        <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="nv">cur</span> <span class="nv">left-tree</span> <span class="nv">right-tree</span><span class="p">)</span> 
          <span class="nv">left-elts</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">elements</span> <span class="p">(</span><span class="nb">count </span><span class="nv">elements</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">list-&gt;tree</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span><span class="p">))</span><span class="c1">; =&gt; (5 (1 nil (3 nil nil)) (9 (7 nil nil) (11 nil nil)))</span>
</code></pre></div><p><code>list-&gt;tree</code> is $O(n)$.</p>
<h3 id="exercise-265">Exercise 2.65</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nb">val </span><span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">L</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">R</span> <span class="nv">last</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">merge-seq</span> <span class="p">[</span><span class="nv">s1</span> <span class="nv">s2</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">s2</span><span class="p">)</span> <span class="nv">s1</span>
        <span class="p">(</span><span class="nf">empty?</span> <span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span>
        <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s2</span><span class="p">))</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">merge-seq</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s2</span><span class="p">))</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s2</span><span class="p">))</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">merge-seq</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s1</span><span class="p">)</span> <span class="nv">s2</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s1</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">merge-seq</span> <span class="nv">s1</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s2</span><span class="p">))</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s2</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">prefix-&gt;infix</span> <span class="p">[</span><span class="nv">t</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">t</span><span class="p">)</span> <span class="nv">nil</span>
        <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">prefix-&gt;infix</span> <span class="p">(</span><span class="nf">L</span> <span class="nv">t</span><span class="p">))</span> <span class="p">(</span><span class="nb">val </span><span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nf">prefix-&gt;infix</span> <span class="p">(</span><span class="nf">R</span> <span class="nv">t</span><span class="p">)))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">tree-&gt;list</span> <span class="p">[</span><span class="nv">t</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">t</span>
       <span class="p">(</span><span class="nf">prefix-&gt;infix</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">flatten</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">%</span><span class="p">)))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">union-set</span> <span class="p">[</span><span class="nv">s1</span> <span class="nv">s2</span><span class="p">]</span> <span class="p">(</span><span class="nf">list-&gt;tree</span> <span class="p">(</span><span class="nf">merge-seq</span> <span class="p">(</span><span class="nf">tree-&gt;list</span> <span class="nv">s1</span><span class="p">)</span> <span class="p">(</span><span class="nf">tree-&gt;list</span> <span class="nv">s2</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-266">Exercise 2.66</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">lookup</span> <span class="p">[</span><span class="nv">given-key</span> <span class="nv">root</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">root</span><span class="p">)</span> <span class="nv">false</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">given-key</span> <span class="p">(</span><span class="nb">key </span><span class="nv">root</span><span class="p">))</span> <span class="p">(</span><span class="nb">val </span><span class="nv">root</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">&lt; </span><span class="nv">given-key</span> <span class="p">(</span><span class="nb">key </span><span class="nv">root</span><span class="p">))</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">given-key</span> <span class="p">(</span><span class="nf">L</span> <span class="nv">root</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">given-key</span> <span class="p">(</span><span class="nf">R</span> <span class="nv">root</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-267">Exercise 2.67</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">leaf</span> <span class="p">[</span><span class="nb">symbol </span><span class="nv">weight</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;leaf</span> <span class="nb">symbol </span><span class="nv">weight</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">leaf?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;leaf</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">symbol-leaf</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">weight</span> <span class="nv">last</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">L</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">R</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">symbols</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">leaf?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">symbol-leaf</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">code-tree</span> <span class="p">[</span><span class="nb">left </span><span class="nv">right</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">list left right </span><span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nf">symbols</span> <span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nf">symbols</span> <span class="nv">right</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">weight</span> <span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nf">weight</span> <span class="nv">right</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">choose-branch</span> <span class="p">[</span><span class="nv">bit</span> <span class="nv">branch</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">bit</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">L</span> <span class="nv">branch</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">bit</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">R</span> <span class="nv">branch</span><span class="p">)</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Exception.</span> <span class="p">(</span><span class="nb">str </span><span class="s">&#34;bad bit: CHOOSE-BRANCH `&#34;</span> <span class="nv">bit</span> <span class="s">&#34;`&#34;</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">decode</span> <span class="p">[</span><span class="nv">bits</span> <span class="nv">tree</span><span class="p">]</span> 
  <span class="p">(</span><span class="kd">defn </span><span class="nv">decode-1</span> <span class="p">[</span><span class="nv">bits</span> <span class="nv">cur</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">bits</span><span class="p">)</span> <span class="p">()</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">next </span><span class="p">(</span><span class="nf">choose-branch</span> <span class="p">(</span><span class="nb">first </span><span class="nv">bits</span><span class="p">)</span> <span class="nv">cur</span><span class="p">)]</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">leaf?</span> <span class="nv">next</span><span class="p">)</span> 
          <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">decode-1</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">bits</span><span class="p">)</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nf">symbol-leaf</span> <span class="nv">next</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">bits</span><span class="p">)</span> <span class="nv">next</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">decode-1</span> <span class="nv">bits</span> <span class="nv">tree</span><span class="p">))</span>

<span class="c1">; The `make-leaf-set` implementation on the book is but a insertion sort.</span>
<span class="c1">; It&#39;s better to used the sort function implemented by Clojure, with a time complexity of O(nlogn)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-leaf-set</span> <span class="p">[</span><span class="nv">pairs</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">pairs</span> 
       <span class="p">(</span><span class="nb">sort-by </span><span class="nv">weight</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">conj </span><span class="nv">%</span> <span class="ss">&#39;leaf</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">sample-tree</span> <span class="p">(</span><span class="nf">code-tree</span> <span class="p">(</span><span class="nf">leaf</span> <span class="ss">&#39;A</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">code-tree</span> <span class="p">(</span><span class="nf">leaf</span> <span class="ss">&#39;B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">code-tree</span> <span class="p">(</span><span class="nf">leaf</span> <span class="ss">&#39;D</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">leaf</span> <span class="ss">&#39;C</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">sample-message</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-268">Exercise 2.68</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">encode-symbol</span> <span class="p">(</span><span class="nf">memoize</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">tree</span> <span class="nv">sym</span><span class="p">]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">travel</span> <span class="p">[</span><span class="nv">rt</span> <span class="nv">cur</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">leaf?</span> <span class="nv">rt</span><span class="p">)</span> 
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">symbol-leaf</span> <span class="nv">rt</span><span class="p">)</span> <span class="nv">sym</span><span class="p">)</span> <span class="nv">cur</span> <span class="nv">false</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">travel</span> <span class="p">(</span><span class="nf">L</span> <span class="nv">rt</span><span class="p">)</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">cur</span> <span class="mi">0</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">travel</span> <span class="p">(</span><span class="nf">R</span> <span class="nv">rt</span><span class="p">)</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">cur</span> <span class="mi">1</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nb">apply list </span><span class="p">(</span><span class="nf">travel</span> <span class="nv">tree</span> <span class="p">[])))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">encode</span> <span class="p">[</span><span class="nv">message</span> <span class="nv">tree</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">message</span><span class="p">)</span> <span class="p">()</span>
    <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nf">encode-symbol</span> <span class="nv">tree</span> <span class="p">(</span><span class="nb">first </span><span class="nv">message</span><span class="p">))</span> <span class="p">(</span><span class="nf">encode</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">message</span><span class="p">)</span> <span class="nv">tree</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-269">Exercise 2.69</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="c1">; https://stackoverflow.com/questions/10942607/clojure-multi-maps</span>
<span class="p">(</span><span class="kd">ns </span><span class="o">#^</span><span class="p">{</span><span class="ss">:doc</span> <span class="s">&#34;A multimap is a map that permits multiple values for each
</span><span class="s">  key.  In Clojure we can represent a multimap as a map with sets as
</span><span class="s">  values.&#34;</span><span class="p">}</span>
  <span class="nv">multimap</span>
  <span class="p">(</span><span class="ss">:use</span> <span class="p">[</span><span class="nv">clojure.set</span> <span class="ss">:only</span> <span class="p">(</span><span class="nf">union</span><span class="p">)]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nb">first </span><span class="p">[</span><span class="nv">mm</span><span class="p">]</span>
  <span class="s">&#34;Get the first key-value pair in the multimap. O(log(n))&#34;</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">k</span> <span class="nv">vs</span><span class="p">]</span> <span class="p">(</span><span class="nf">clojure.core/first</span> <span class="nv">mm</span><span class="p">)]</span>
    <span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">clojure.core/first</span> <span class="nv">vs</span><span class="p">)]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nb">rest </span><span class="p">[</span><span class="nv">mm</span><span class="p">]</span>
  <span class="s">&#34;Get the multimap after dropping the first key-value pair. O(log(n))&#34;</span>
   <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">k</span> <span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nb">first </span><span class="nv">mm</span><span class="p">)]</span>
     <span class="p">(</span><span class="nf">del</span> <span class="nv">mm</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nb">second </span><span class="p">[</span><span class="nv">mm</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">rest </span><span class="nv">mm</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">add</span>
  <span class="s">&#34;Adds key-value pairs the multimap.&#34;</span>
  <span class="p">([</span><span class="nv">mm</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">assoc </span><span class="nv">mm</span> <span class="nv">k</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">get </span><span class="nv">mm</span> <span class="nv">k</span> <span class="o">#</span><span class="p">{})</span> <span class="nv">v</span><span class="p">)))</span>
  <span class="p">([</span><span class="nv">mm</span> <span class="nv">k</span> <span class="nv">v</span> <span class="o">&amp;</span> <span class="nv">kvs</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">apply </span><span class="nv">add</span> <span class="p">(</span><span class="nf">add</span> <span class="nv">mm</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">)</span> <span class="nv">kvs</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">del</span>
  <span class="s">&#34;Removes key-value pairs from the multimap.&#34;</span>
  <span class="p">([</span><span class="nv">mm</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">]</span>
     <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">mmv</span> <span class="p">(</span><span class="nb">disj </span><span class="p">(</span><span class="nb">get </span><span class="nv">mm</span> <span class="nv">k</span><span class="p">)</span> <span class="nv">v</span><span class="p">)]</span>
       <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">seq </span><span class="nv">mmv</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">assoc </span><span class="nv">mm</span> <span class="nv">k</span> <span class="nv">mmv</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">dissoc </span><span class="nv">mm</span> <span class="nv">k</span><span class="p">))))</span>
  <span class="p">([</span><span class="nv">mm</span> <span class="nv">k</span> <span class="nv">v</span> <span class="o">&amp;</span> <span class="nv">kvs</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">apply </span><span class="nv">del</span> <span class="p">(</span><span class="nf">del</span> <span class="nv">mm</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">)</span> <span class="nv">kvs</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">mm-merge</span>
  <span class="s">&#34;Merges the multimaps, taking the union of values.&#34;</span>
  <span class="p">[</span><span class="o">&amp;</span> <span class="nv">mms</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nb">partial merge-with </span><span class="nv">union</span><span class="p">)</span> <span class="nv">mms</span><span class="p">))</span>


<span class="p">(</span><span class="kd">ns </span><span class="nv">user</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">successive-merge</span> <span class="p">[</span><span class="nv">cnt</span> <span class="nv">pairs</span><span class="p">]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">iter</span> <span class="p">[</span><span class="nv">pairs</span> <span class="nv">n</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">second </span><span class="p">(</span><span class="nf">multimap/first</span> <span class="nv">pairs</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">new-node</span> <span class="p">(</span><span class="nf">code-tree</span> <span class="p">(</span><span class="nb">second </span><span class="p">(</span><span class="nf">multimap/first</span> <span class="nv">pairs</span><span class="p">))</span> <span class="p">(</span><span class="nb">second </span><span class="p">(</span><span class="nf">multimap/second</span> <span class="nv">pairs</span><span class="p">)))</span> 
            <span class="nv">rest-pairs</span> <span class="p">(</span><span class="nf">multimap/rest</span> <span class="p">(</span><span class="nf">multimap/rest</span> <span class="nv">pairs</span><span class="p">))]</span>
        <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">multimap/add</span> <span class="nv">rest-pairs</span> <span class="p">(</span><span class="nf">weight</span> <span class="nv">new-node</span><span class="p">)</span> <span class="nv">new-node</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">iter</span> <span class="nv">pairs</span> <span class="p">(</span><span class="nb">- </span><span class="nv">cnt</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">huffman-tree</span> <span class="p">[</span><span class="nv">pairs</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cnt</span> <span class="p">(</span><span class="nb">count </span><span class="nv">pairs</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">pairs</span>
         <span class="p">(</span><span class="nf">make-leaf-set</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">cur</span> <span class="nv">i</span><span class="p">]</span> <span class="p">(</span><span class="nf">multimap/add</span> <span class="nv">cur</span> <span class="p">(</span><span class="nf">weight</span> <span class="nv">i</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span> <span class="p">(</span><span class="nf">sorted-map</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">successive-merge</span> <span class="nv">cnt</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-270">Exercise 2.70</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">dictionary</span> <span class="p">(</span><span class="nf">huffman-tree</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">A</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">NA</span> <span class="mi">16</span><span class="p">)</span> <span class="p">(</span><span class="nf">BOOM</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">SHA</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">GET</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">YIP</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="nf">JOB</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">WAH</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">message</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">GET</span> <span class="nv">A</span> <span class="nv">JOB</span> <span class="nv">SHA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">GET</span> <span class="nv">A</span> <span class="nv">JOB</span> <span class="nv">SHA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">NA</span> <span class="nv">WAH</span> <span class="nv">YIP</span> <span class="nv">YIP</span> <span class="nv">YIP</span> <span class="nv">YIP</span> <span class="nv">YIP</span> <span class="nv">YIP</span> <span class="nv">YIP</span> <span class="nv">YIP</span> <span class="nv">YIP</span> <span class="nv">SHA</span> <span class="nv">BOOM</span><span class="p">))</span>
<span class="p">(</span><span class="nf">encode</span> <span class="nv">message</span> <span class="nv">dictionary</span><span class="p">)</span><span class="c1">; 84 bit in total</span>
</code></pre></div><p>For a fixed-length code, it would take $36 \times 3 = 108 \text{(bits)}$.</p>
<h3 id="exercise-271">Exercise 2.71</h3>
<p>I just draw it for n = 2, n = 5 and n = 10 are similar.</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="2-71-hoffman-tree-example.png"
        data-srcset="2-71-hoffman-tree-example.png, 2-71-hoffman-tree-example.png 1.5x, 2-71-hoffman-tree-example.png 2x"
        data-sizes="auto"
        alt="2-71-hoffman-tree-example.png"
        title="A chain like Hoffman Tree for n = 2." /></p>
<p>It requires 1 bit to encode the most frequent symbol, while $2^n$ bit to encode the least frequent symbol.</p>
<h3 id="exercise-272">Exercise 2.72</h3>
<p>It takes $O(1)$ to encode the most frequent symbol in Exercise 2.71, while $O(2^n)$ to encode the least frequent symbol in Exercise 2.71.</p>
<h3 id="exercise-273">Exercise 2.73</h3>
<h4 id="1-2">1)</h4>
<p>The code treat the exp as a general kind of data, tagged <code>sum</code> or <code>product</code>. Then it seperate the differentiation part of each implementation out of the general <code>deriv</code> function.</p>
<p><code>number</code> and <code>variable</code> are special since they don&rsquo;t act like some operation, operating on operators and operands.</p>
<h4 id="2--3">2) &amp; 3)</h4>
<p>Clojure requires pure functional programming, so there&rsquo;s no way to &ldquo;install&rdquo; some modules.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">drop-nth</span> <span class="p">[</span><span class="nv">n</span> <span class="nv">coll</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">keep-indexed</span> <span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not= </span><span class="nv">%1</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">%2</span><span class="p">)</span> <span class="nv">coll</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">variable?</span> <span class="nv">symbol?</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">operator</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">operands</span> <span class="nv">rest</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">deriv</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-sum</span> <span class="p">[</span><span class="nv">a1</span> <span class="nv">a2</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">a1</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a2</span> 
        <span class="p">(</span><span class="nb">= </span><span class="nv">a2</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a1</span>
        <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nf">number?</span> <span class="nv">a2</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;+</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-product</span> <span class="p">[</span><span class="nv">a1</span> <span class="nv">a2</span><span class="p">]</span> 
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">a1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">a2</span> <span class="mi">0</span><span class="p">))</span> <span class="mi">0</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">a1</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">a2</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">a2</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">a1</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;*</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-exponentiation</span> <span class="p">[</span><span class="nv">u</span> <span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">u</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">1</span>
        <span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">u</span>
        <span class="ss">:else</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;**</span> <span class="nv">u</span> <span class="nv">n</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">addend</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">augend</span> <span class="p">[</span><span class="nv">exp</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">second </span><span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">concat </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">+</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">exp</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">deriv-+</span> <span class="p">[</span><span class="nv">exp</span> <span class="nv">var</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">addend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">augend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">multiplier</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">multiplicand</span> <span class="p">[</span><span class="nv">exp</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">second </span><span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">concat </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">*</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">exp</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">deriv-*</span> <span class="p">[</span><span class="nv">exp</span> <span class="nv">var</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">make-product</span> 
              <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">make-product</span> 
              <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">base</span> <span class="nv">first</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">exponent</span> <span class="nv">second</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">deriv-**</span> <span class="p">[</span><span class="nv">exp</span> <span class="nv">var</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">make-product</span> 
                  <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">make-exponentiation</span>
                    <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span> 
                    <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span> <span class="mi">-1</span><span class="p">)))</span> 
                <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>


<span class="p">(</span><span class="k">def </span><span class="nv">ops-map</span> <span class="p">{</span>
  <span class="p">[</span><span class="ss">&#39;deriv</span> <span class="ss">&#39;+</span><span class="p">]</span> <span class="nv">deriv-+</span>, 
  <span class="p">[</span><span class="ss">&#39;deriv</span> <span class="ss">&#39;*</span><span class="p">]</span> <span class="nv">deriv-*</span>,
  <span class="p">[</span><span class="ss">&#39;deriv</span> <span class="ss">&#39;**</span><span class="p">]</span> <span class="nv">deriv-**</span>
<span class="p">})</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">deriv</span> <span class="p">[</span><span class="nv">exp</span> <span class="nv">var</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">exp</span><span class="p">)</span> <span class="mi">0</span>
        <span class="p">(</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
        <span class="ss">:else</span>
          <span class="p">((</span><span class="nb">get </span><span class="nv">ops-map</span> <span class="p">[</span><span class="ss">&#39;deriv</span> <span class="p">(</span><span class="nf">operator</span> <span class="nv">exp</span><span class="p">)])</span> <span class="p">(</span><span class="nf">operands</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>

</code></pre></div><h4 id="4">4)</h4>
<p>In the example on the book, you should only change the implementation of <code>get</code>, <code>put</code>, and calls to them.</p>
<p>In my code you can just change the map <code>ops-map</code> and the calls to the function <code>get</code>.</p>
<h3 id="exercise-274">Exercise 2.74</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">get-record</span> 
  <span class="s">&#34;the employee&#39;s id and the file should be supplied. &#34;</span>
  <span class="p">([</span><span class="nv">id</span> <span class="nv">file</span><span class="p">]</span> <span class="c1">; O(n)</span>
    <span class="p">(</span><span class="nb">first </span>
      <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">record</span> <span class="nv">file</span>
            <span class="ss">:let</span> <span class="p">[</span><span class="nv">cur-id</span> <span class="p">(</span><span class="ss">:id</span> <span class="nv">record</span><span class="p">)]</span>
            <span class="ss">:when</span> <span class="p">(</span><span class="nb">= </span><span class="nv">cur-id</span> <span class="nv">id</span><span class="p">)]</span> <span class="nv">record</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">find-employee-record</span> 
  <span class="s">&#34;The set of all files should be supplied. 
</span><span class="s">   It should be structured like this: 
</span><span class="s">   &#39;(({:id Tom :salary 10} {:id Jerry :salary 100}) 
</span><span class="s">     ({:id Alpha :salary 10} {:id Bravo :salary 100}))
</span><span class="s">   That is, a list of list of maps. &#34;</span>
  <span class="p">([</span><span class="nv">id</span> <span class="nv">files</span><span class="p">]</span> <span class="c1">; O(n)</span>
    <span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">(</span><span class="nf">get-record</span> <span class="nv">id</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">files</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">get-salary</span> <span class="p">[</span><span class="nv">id</span> <span class="nv">files</span><span class="p">]</span> 
  <span class="p">(</span><span class="ss">:salary</span> <span class="p">(</span><span class="nf">find-employee-record</span> <span class="nv">id</span> <span class="nv">files</span><span class="p">)))</span>
</code></pre></div><p>Only change the function <code>get-record</code>.</p>
<h3 id="exercise-275">Exercise 2.75</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">make-from-mag-ang</span> <span class="p">[</span><span class="nv">rho</span> <span class="nv">theta</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">op</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">op</span> <span class="ss">&#39;real-part</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">rho</span> <span class="p">(</span><span class="nf">Math/cos</span> <span class="nv">theta</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">= </span><span class="nv">op</span> <span class="ss">&#39;imag-part</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">rho</span> <span class="p">(</span><span class="nf">Math/sin</span> <span class="nv">theta</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">= </span><span class="nv">op</span> <span class="ss">&#39;magnitude</span><span class="p">)</span> <span class="nv">rho</span>
          <span class="p">(</span><span class="nb">= </span><span class="nv">op</span> <span class="ss">&#39;angle</span><span class="p">)</span> <span class="nv">theta</span>
          <span class="ss">:else</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Exception.</span> <span class="p">(</span><span class="nb">str </span><span class="s">&#34;Unknown op: MAKE-FROM-MAG-ANG&#34;</span> <span class="nv">op</span><span class="p">))))))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">apply-generic</span> <span class="p">[</span><span class="nv">op</span> <span class="nv">arg</span><span class="p">]</span> <span class="p">(</span><span class="nf">arg</span> <span class="nv">op</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-276">Exercise 2.76</h3>
<p>For explicit dispatch:</p>
<p>every operation should be implement as a conditional procudure, considering different inputs.</p>
<p>For data-directed style:</p>
<p>operations on types forms a 2-dimension array, implementation of the operations are in the arrays.</p>
<p>For message-passing style:</p>
<p>The operations on a specific types should always be implemented in the definition of that type.</p>
<p>For a system in which new types must be often added, message-passing style is more appropriate.</p>
<p>For a system in which new operations must often be added, explicit dispatch is more appropriate.</p>
<h3 id="exercise-277">Exercise 2.77</h3>
<p>This adds a interface for the <code>complex</code> numbers, so it works.</p>
<p>For the second question, my implementation differs from the one on the book (I&rsquo;m using clojure).</p>
<p>In my implementation, I straightly call the functions in the module <code>complex</code>, so no <code>apply-generic</code> is called.</p>
<p>The <code>magnitude</code> function calls  <code>complex/magnitude</code>, and then <code>base/val</code>.</p>
<h3 id="exercise-278281-283--285">Exercise 2.78~2.81, 2.83 ~ 2.85</h3>
<p>See: <a href="https://github.com/glyh/sicp-solutions-clojure/tree/main/src/sicp_solutions_clojure/chapter_2/algebraic_system" target="_blank" rel="noopener noreferrer">sicp-solutions on my github.</a></p>
<h3 id="exercise-281">Exercise 2.81</h3>
<p>Stack overflows, since the function keeps calling itself.</p>
<h3 id="exercise-282">Exercise 2.82</h3>
<p>The method mentioned in the question is not good, for example, we have type a, b and c.</p>
<p>Let&rsquo;s say a, b and c are all supertypes of some d, but there&rsquo;s no way to convert between them.</p>
<p>If so, trying to coerce between them won&rsquo;t lay out the result we want.</p>
<p>A proper way to solve this, might be treat the types relationships as a DAG. For each variable x to be applied by the operation,add a set on the node with the type in it, unioning the sets in the direction of the edges goes, and see whether there&rsquo;s some type have all types of inputed variables.</p>
<p>If there is some type fullfilled the requirements, then we can coerce to that type; If not we can&rsquo;t apply this method.</p>
<p>This is only a trivial solution. There might be better ways, but requires deeper knowledges on algorithms.</p>
<p>*[DAG]: Directed Acyclic Graph</p>
<p>*[DP]: Dynamic Programming</p>
<h3 id="exercise-286">Exercise 2.86</h3>
<p>Nothing to change since ratio is treated as primitive in Clojure.</p>
<p>If you stick to this, we could insert some layers between <code>complex</code> and the under layers it relies on.</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span></span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/algorithms/">algorithms</a>,&nbsp;<a href="/tags/principles/">principles</a>,&nbsp;<a href="/tags/lisp/">LISP</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();"></a></span>&nbsp;|&nbsp;<span><a href="/"></a></span>
        </section>
    </div>

    <div class="post-nav">
            <a href="/posts/sicp-solutions-in-clojure-chapter-1/" class="next" rel="next" title="SICP Solutions in Clojure (Chapter 1)">SICP Solutions in Clojure (Chapter 1)<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer">lyhokia</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"","maxShownLines":10},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
