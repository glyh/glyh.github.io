<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>SICP Solutions in Clojure (Chapter 1) - Newbie@Corner</title><meta name="description" content=""><meta property="og:title" content="SICP Solutions in Clojure (Chapter 1)" />
<meta property="og:description" content="I&rsquo;m learning Clojure and SICP these days, and trying to finish the exercises on
the SICP." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://glyh.github.io/posts/sicp-solutions-in-clojure-chapter-1/" />
<meta property="article:published_time" content="2021-02-03T16:39:00+08:00" />
<meta property="article:modified_time" content="2021-02-03T16:39:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SICP Solutions in Clojure (Chapter 1)"/>
<meta name="twitter:description" content="I&rsquo;m learning Clojure and SICP these days, and trying to finish the exercises on
the SICP."/>
<meta name="application-name" content="Newbie@Corner">
<meta name="apple-mobile-web-app-title" content="Newbie@Corner"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://glyh.github.io/posts/sicp-solutions-in-clojure-chapter-1/" /><link rel="prev" href="https://glyh.github.io/posts/sicp-solutions-in-clojure-chapter-2/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "SICP Solutions in Clojure (Chapter 1)",
        "inLanguage": "en-us",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/glyh.github.io\/posts\/sicp-solutions-in-clojure-chapter-1\/"
        },"genre": "posts","keywords": "algorithms, principles, LISP","wordcount":  3070 ,
        "url": "https:\/\/glyh.github.io\/posts\/sicp-solutions-in-clojure-chapter-1\/","datePublished": "2021-02-03T16:39:00+08:00","dateModified": "2021-02-03T16:39:00+08:00","publisher": {
            "@type": "Organization",
            "name": "lyhokia"},"author": {
                "@type": "Person",
                "name": "lyhokia"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Newbie@Corner">Newbie@Corner</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Newbie@Corner">Newbie@Corner</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title"></h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">SICP Solutions in Clojure (Chapter 1)</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>lyhokia</a></span>&nbsp;<span class="post-category"></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-02-03">2021-02-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span></span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#exercise-11">Exercise 1.1</a></li>
        <li><a href="#exercise-12">Exercise 1.2</a></li>
        <li><a href="#exercise-13">Exercise 1.3</a></li>
        <li><a href="#exercise-14">Exercise 1.4</a></li>
        <li><a href="#exercise-15">Exercise 1.5</a></li>
        <li><a href="#exercise-16">Exercise 1.6</a></li>
        <li><a href="#exercise-17">Exercise 1.7</a></li>
        <li><a href="#exercise-18">Exercise 1.8</a></li>
        <li><a href="#exercise-19">Exercise 1.9</a></li>
        <li><a href="#exercise-110">Exercise 1.10</a></li>
        <li><a href="#exercise-111">Exercise 1.11</a></li>
        <li><a href="#exercise-112">Exercise 1.12</a></li>
        <li><a href="#exercise-113">Exercise 1.13</a></li>
        <li><a href="#exerciese-114">Exerciese 1.14</a></li>
        <li><a href="#exercise-115">Exercise 1.15</a></li>
        <li><a href="#exercise-116">Exercise 1.16</a></li>
        <li><a href="#exercise-117">Exercise 1.17</a></li>
        <li><a href="#exercise-118">Exercise 1.18</a></li>
        <li><a href="#exercise-119">Exercise 1.19</a></li>
        <li><a href="#exercise-120">Exercise 1.20</a></li>
        <li><a href="#exercise-121">Exercise 1.21</a></li>
        <li><a href="#exercise-122">Exercise 1.22</a></li>
        <li><a href="#exercise-123">Exercise 1.23</a></li>
        <li><a href="#exercise-124">Exercise 1.24</a></li>
        <li><a href="#exercise-125">Exercise 1.25</a></li>
        <li><a href="#exercise-126">Exercise 1.26</a></li>
        <li><a href="#exercise-127">Exercise 1.27</a></li>
        <li><a href="#exercise-128">Exercise 1.28</a></li>
        <li><a href="#exercise-129">Exercise 1.29</a></li>
        <li><a href="#exercise-130">Exercise 1.30</a></li>
        <li><a href="#exercise-131">Exercise 1.31</a></li>
        <li><a href="#exercise-132">Exercise 1.32</a></li>
        <li><a href="#exercise-133">Exercise 1.33</a></li>
        <li><a href="#exercise-134">Exercise 1.34</a></li>
        <li><a href="#exercise-135">Exercise 1.35</a></li>
        <li><a href="#exercise-136">Exercise 1.36</a></li>
        <li><a href="#exercise-137">Exercise 1.37</a></li>
        <li><a href="#exercise-138">Exercise 1.38</a></li>
        <li><a href="#exercise-139">Exercise 1.39</a></li>
        <li><a href="#exercise-140">Exercise 1.40</a></li>
        <li><a href="#exercise-141">Exercise 1.41</a></li>
        <li><a href="#exercise-142">Exercise 1.42</a></li>
        <li><a href="#exercise-143">Exercise 1.43</a></li>
        <li><a href="#exercise-144">Exercise 1.44</a></li>
        <li><a href="#exercise-145">Exercise 1.45</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>I&rsquo;m learning Clojure and SICP these days, and trying to finish the exercises on
the SICP.</p>
<h3 id="exercise-11">Exercise 1.1</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="mi">3</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)]</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">10</span>
           <span class="p">(</span><span class="nb">+ </span><span class="mi">5</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">- </span><span class="mi">9</span> <span class="mi">1</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">/ </span><span class="mi">6</span> <span class="mi">2</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="mi">4</span> <span class="mi">6</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
           <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">b</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt; </span><span class="nv">b</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">6</span> <span class="p">(</span><span class="nb">= </span><span class="nv">b</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">6</span> <span class="mi">7</span> <span class="nv">a</span><span class="p">)</span> <span class="ss">:else</span> <span class="mi">25</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">b</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">&lt; </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span> <span class="ss">:else</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">))]]</span>
 <span class="p">(</span><span class="nb">println </span><span class="nv">x</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-12">Exercise 1.2</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="mi">5</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">- </span><span class="mi">2</span> <span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">6</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">4</span> <span class="mi">3</span><span class="p">)))))</span> <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="p">(</span><span class="nb">- </span><span class="mi">6</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="mi">2</span> <span class="mi">7</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-13">Exercise 1.3</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">sum-of-sqaures-of-two-biggest</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">sort </span><span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]))</span> <span class="nv">sec</span> <span class="p">(</span><span class="nb">second </span><span class="nv">s</span><span class="p">)</span> <span class="nv">thi</span> <span class="p">(</span><span class="nb">last </span><span class="nv">s</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">sec</span> <span class="nv">sec</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">thi</span> <span class="nv">thi</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">sum-of-sqaures-of-two-biggest</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-14">Exercise 1.4</h3>
<p>Just as the function&rsquo;s name, the function will return  $a + \lvert b \rvert$ .</p>
<h3 id="exercise-15">Exercise 1.5</h3>
<p>The following form doesn&rsquo;t have a valid syntax in Clojure.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">p</span><span class="p">))</span>
</code></pre></div><p>Let&rsquo;s suppose it is valid.</p>
<p>If we&rsquo;re under applicative-order evaluation, the function will return 0, since (p) is not evaluated.</p>
<p>If we&rsquo;re under normal-order evaluation, the function will fall in to a dead loop.</p>
<h3 id="exercise-16">Exercise 1.6</h3>
<p>This would fall into a dead loop.</p>
<p>Different from evaluation of the special form <code>cond</code>, the function call requires every parameter to be evaluated.</p>
<p>There is only one exit in the <code>sqrt-iter</code>, which calls <code>sqrt-iter</code> itself, result in a dead loop.</p>
<h3 id="exercise-17">Exercise 1.7</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">abs</span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">eps</span> <span class="mi">1</span><span class="nv">e-8</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">sqrt</span>
  <span class="p">([</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">sqrt</span> <span class="nv">x</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">x</span> <span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">abs</span> <span class="p">(</span><span class="nb">- </span><span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">))</span> <span class="nv">eps</span><span class="p">)</span>
      <span class="nv">guess</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">double </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="nv">guess</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">guess</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span> <span class="nv">guess</span><span class="p">))))</span>
      <span class="c1">; use `double` to convert ratio to float numbers, avoiding overflow.</span>

<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">sqrt</span> <span class="mi">121</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-18">Exercise 1.8</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">abs</span>
  <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">eps</span> <span class="mi">1</span><span class="nv">e-8</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">cube-root</span>
  <span class="p">([</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">cube-root</span> <span class="nv">x</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">x</span> <span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">abs</span> <span class="p">(</span><span class="nb">- </span><span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">))</span> <span class="nv">eps</span><span class="p">)</span>
      <span class="nv">guess</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="nv">x</span>
             <span class="p">(</span><span class="nb">double </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">guess</span><span class="p">)</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="p">(</span><span class="nb">* </span><span class="nv">guess</span> <span class="nv">guess</span><span class="p">)))</span> <span class="mi">3</span><span class="p">))</span>
             <span class="nv">guess</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">cube-root</span> <span class="mf">0.00483</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-19">Exercise 1.9</h3>
<p>The first one is recursive while the second one is iterative.</p>
<h3 id="exercise-110">Exercise 1.10</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">A</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">y</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span>
    <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">= </span><span class="nv">y</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span>
    <span class="ss">:else</span> <span class="p">(</span><span class="nf">A</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">A</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">v</span> <span class="p">[[</span><span class="mi">1</span> <span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">4</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="mi">3</span><span class="p">]]]</span>
  <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">apply </span><span class="nv">A</span> <span class="nv">v</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">f</span>
  <span class="s">&#34;Calculate 2 * n&#34;</span>
  <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">g</span>
  <span class="s">&#34;Calculate 2 ^ n&#34;</span>
  <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">h</span>
  <span class="s">&#34;Calculate 2 ^ 2 ^ 2 ^ 2 ^ 2 ... ^ 2 (there are n 2&#39;s in total)&#34;</span>
  <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">2</span> <span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">h</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-111">Exercise 1.11</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">f</span>
    <span class="p">([</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="p">([</span><span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">f</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-112">Exercise 1.12</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">pascal-triangle</span>
  <span class="p">([</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">pascal-triangle</span> <span class="nv">n</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]))</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">l</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="nv">n</span><span class="p">)</span>
      <span class="nv">l</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">conj </span><span class="nv">l</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="nv">+</span>
             <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">last </span><span class="nv">l</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="p">(</span><span class="nb">last </span><span class="nv">l</span><span class="p">)))))))))</span>

<span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nf">pascal-triangle</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-113">Exercise 1.13</h3>
<p>$$
\lvert Fib(n) - \frac{\phi^n}{5} \rvert = \frac{\psi^n}{5} &lt; \frac{\psi}{5} &lt; \frac{1}{2},\square.
$$</p>
<p>(To be continued &hellip;)</p>
<h3 id="exerciese-114">Exerciese 1.14</h3>
<h4 id="graph">Graph</h4>
<div class="mermaid" id="id-1"></div>
<h4 id="space-complexity">Space complexity</h4>
<p>It’s easy to observe the space complexity is $O(max{m, n})$.</p>
<h4 id="time-complexity">Time complexity</h4>
<p>Let&rsquo;s suppose n be the money to be changed, m be the count of type of coins, $V_m$ be the denomination of the coin of mth type.</p>
<p>The following is only a rough estimate.</p>
<p>$$
\begin{aligned}
&amp;T(n, m) &amp;=&amp; \sum_{i=0}^{\lceil\frac{n}{V_m}\rceil}T(n-iV_m, m-1)+O(1)&amp; \<br>
&amp;&amp;=&amp;O(\lceil\frac{n}{V_m}\rceil T(n, m-1))&amp; \<br>
&amp;&amp;=&amp;O(\prod_{i=1}^{m}\lceil\frac{n}{V_m}\rceil T(n, 0))&amp; \<br>
&amp;&amp;=&amp;O(n^m)&amp;
\end{aligned}
$$</p>
<p>For m = 5, there  there is a closer estimate, implying that this algorithm has a time complexity of $\Theta(n^5)$ in <a href="https://codology.net/post/sicp-solution-exercise-1-14/" target="_blank" rel="noopener noreferrer">codology.net</a>.</p>
<h4 id="optimization-on-time-complexity">Optimization on time complexity</h4>
<p>If you examine the “tree” given before, you’ll realize that it’s actually not a tree. It’s a topological graph.</p>
<p>In the original tree, there is a lot of repeating tree nodes, calculating the same value of the recursive function.</p>
<p>If we save the value of every calculated function, the time complexity will be $O(nm)$ , since there are only $n \times m$ states in total.</p>
<p>For Clojure, using <code>memoize</code> will simply complete the job for you.</p>
<p>However, the space complexity will fall to $O(n \times m)$ , but usally the optimization as a whole is a great deal.</p>
<p>This kind of way of solving problems are actually DP. Notice: This kind of optimization only works for referentially transparent functions, that is, the function’s output only relates to its input.</p>
<p>*[DP]: Dynamic Programming</p>
<h3 id="exercise-115">Exercise 1.15</h3>
<h4 id="a">a)</h4>
<p>Solve the inequality $\lvert\frac{\theta}{3^n}\rvert \leq 0.1(\theta = 12.15)$ yields $n_{min} = 5$ .</p>
<p>Therefore, the function p is called 5 times.</p>
<h4 id="b-time--space-complexity">b) Time &amp; space complexity</h4>
<p>$$
\begin{aligned}
&amp;T(p(x))&amp;=&amp;O(1)&amp; \<br>
&amp;T(sine(x))&amp;=&amp;\left{\begin{aligned}
&amp;T(sine(\frac{x}{3})) + T(p(x)),  &amp;\forall \lvert x\rvert &gt; 0.1&amp; \<br>
&amp;O(1), &amp;\forall \lvert x\rvert \le 0.1&amp;
\end{aligned}\right.&amp; \<br>
&amp;&amp;=&amp;O(log(n))&amp;
\end{aligned}
$$</p>
<p>The space complexity is the same as time complexity.</p>
<h3 id="exercise-116">Exercise 1.16</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fast-expt</span>
  <span class="p">([</span><span class="nv">b</span> <span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">fast-expt</span> <span class="mi">1</span><span class="nv">N</span> <span class="nv">b</span> <span class="nv">n</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">n</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a</span>
          <span class="p">(</span><span class="nf">even?</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">* </span><span class="nv">b</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">n</span> <span class="mi">2</span><span class="p">))</span>
          <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">fast-expt</span> <span class="mi">9321233</span><span class="nv">N</span> <span class="mi">112</span><span class="nv">N</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-117">Exercise 1.17</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">_double</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">_half</span> <span class="o">#</span><span class="p">(</span><span class="nb">/ </span><span class="nv">%</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fast-mul</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span>
              <span class="p">(</span><span class="nf">even?</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">fast-mul</span> <span class="p">(</span><span class="nf">_double</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">_half</span> <span class="nv">b</span><span class="p">))</span>
              <span class="ss">:else</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="p">(</span><span class="nf">fast-mul</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">- </span><span class="nv">b</span> <span class="mi">1</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">fast-mul</span> <span class="mi">12321411231231231</span><span class="nv">N</span> <span class="mi">12423112312312312321</span><span class="nv">N</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-118">Exercise 1.18</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">_double</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">_half</span> <span class="o">#</span><span class="p">(</span><span class="nb">/ </span><span class="nv">%</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fast-mul</span>
  <span class="p">([</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nf">fast-mul</span> <span class="nv">a</span> <span class="nv">b</span> <span class="mi">0</span><span class="nv">N</span><span class="p">))</span>
  <span class="c1">; a * b + cur = constant</span>
  <span class="p">([</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">cur</span><span class="p">]</span> <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">cur</span>
                   <span class="p">(</span><span class="nf">even?</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">_double</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">_half</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">cur</span><span class="p">)</span>
                   <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">- </span><span class="nv">b</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">cur</span> <span class="nv">a</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">fast-mul</span> <span class="mi">12321411231231231</span><span class="nv">N</span> <span class="mi">12423112312312312321</span><span class="nv">N</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-119">Exercise 1.19</h3>
<p>This is an application of Exponentiation by <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring" target="_blank" rel="noopener noreferrer">squaring</a>.</p>
<p>$$
\begin{aligned}
\text{Let A be a } 2 \times 2 \text{ matrix, s.t.} \<br>
A \times \begin{bmatrix} b \ a \end{bmatrix} = \begin{bmatrix} bp+aq \bq+aq+ap \end{bmatrix} \<br>
\text{We have } A = \begin{bmatrix} p &amp; q \ q &amp; p+q \end{bmatrix} \<br>
A^2 = \begin{bmatrix} p^2+q^2 &amp; 2pq+q^2 \ 2pq+q^2 &amp; p^2 + 2pq + 2q^2 \end{bmatrix} \<br>
p'=p^2+q^2, q'=2pq+q^2
\end{aligned}
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">fib</span>
  <span class="p">([</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">fib</span> <span class="mi">1</span><span class="nv">N</span> <span class="mi">0</span><span class="nv">N</span> <span class="mi">0</span><span class="nv">N</span> <span class="mi">1</span><span class="nv">N</span> <span class="nv">n</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">cnt</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="nv">cnt</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">b</span>
          <span class="p">(</span><span class="nf">even?</span> <span class="nv">cnt</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">a</span> <span class="nv">b</span>
                             <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">p</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">q</span> <span class="nv">q</span><span class="p">))</span>
                             <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">q</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">p</span> <span class="nv">q</span><span class="p">))</span>
                             <span class="p">(</span><span class="nb">/ </span><span class="nv">cnt</span> <span class="mi">2</span><span class="p">))</span>
          <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">b</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">p</span><span class="p">))</span>
                       <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">b</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">q</span><span class="p">))</span>
                       <span class="nv">p</span>
                       <span class="nv">q</span>
                       <span class="p">(</span><span class="nb">- </span><span class="nv">cnt</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">fib</span> <span class="mi">10000</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-120">Exercise 1.20</h3>
<p>Applicative order evaluation, applying the mod operation for 4 times.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">gcd</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span><span class="c1">; =&gt; (Call once)</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">40</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">206</span> <span class="p">(</span><span class="nf">gcd</span> <span class="mi">40</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">)))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">gcd</span> <span class="mi">40</span> <span class="p">(</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">gcd</span> <span class="mi">40</span> <span class="mi">6</span><span class="p">)</span><span class="c1">; =&gt; (Call twice)</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">6</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">40</span> <span class="p">(</span><span class="nf">gcd</span> <span class="mi">6</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">40</span> <span class="mi">6</span><span class="p">)))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">gcd</span> <span class="mi">6</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">40</span> <span class="mi">6</span><span class="p">))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">gcd</span> <span class="mi">6</span> <span class="mi">4</span><span class="p">)</span><span class="c1">; =&gt; (Call 3 times)</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">4</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">6</span> <span class="p">(</span><span class="nf">gcd</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">6</span> <span class="mi">4</span><span class="p">)))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">gcd</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">6</span> <span class="mi">4</span><span class="p">))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">gcd</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span><span class="c1">; =&gt; (Call 4 times)</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">4</span> <span class="p">(</span><span class="nf">gcd</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">4</span> <span class="mi">2</span><span class="p">)))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">gcd</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">4</span> <span class="mi">2</span><span class="p">))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">gcd</span> <span class="mi">2</span> <span class="mi">0</span><span class="p">)</span><span class="c1">; =&gt; (Call 5 times)</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">gcd</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">2</span> <span class="mi">0</span><span class="p">)))</span><span class="c1">; =&gt;</span>

<span class="mi">2</span>
</code></pre></div><p>Normal order evaluation:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">40</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">206</span> <span class="p">(</span><span class="nf">gcd</span> <span class="mi">40</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">)))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">40</span> <span class="mi">0</span><span class="p">)</span>
  <span class="mi">206</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">40</span>
    <span class="p">(</span><span class="nf">gcd</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">)</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">40</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">)))))</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">40</span> <span class="mi">0</span><span class="p">)</span>
  <span class="mi">206</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">40</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="mi">40</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">))</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">gcd</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">40</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">))</span> <span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="mi">206</span> <span class="mi">40</span><span class="p">))</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">40</span> <span class="p">(</span><span class="nb">rem </span><span class="mi">206</span> <span class="mi">40</span><span class="p">)))))))</span><span class="c1">; =&gt;</span>

<span class="nv">......</span>
</code></pre></div><p>Suppose after expanding the ith <code>gcd</code>, we call <code>rem</code> f(i) times, then:</p>
<p>$$
\begin{aligned}
&amp;f(0)&amp;=&amp;0&amp; \<br>
&amp;f(i+1)&amp;=&amp;3f(i)+1&amp;
\end{aligned}</p>
<p>$$</p>
<p>In the applicative order, gcd is called 5 times, so the answer is:</p>
<p>$$</p>
<p>f(5) = 3^5(f(0)+\frac{1}{2})-\frac{1}{2}=121</p>
<p>$$</p>
<h3 id="exercise-121">Exercise 1.21</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">smallest-divisor</span>
  <span class="p">([</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">smallest-divisor</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">]</span> <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">* </span><span class="nv">test-divisor</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">n</span>
                          <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">test-divisor</span>
                          <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">test-divisor</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">map </span><span class="nv">smallest-divisor</span> <span class="p">[</span><span class="mi">199</span> <span class="mi">1999</span> <span class="mi">19999</span><span class="p">])</span>
</code></pre></div><h3 id="exercise-122">Exercise 1.22</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">prime?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">every? </span><span class="o">#</span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nf">mod</span> <span class="nv">x</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nf">Math/sqrt</span> <span class="nv">x</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">range-to-inf</span> <span class="p">[</span><span class="nv">low-bound</span><span class="p">]</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="nv">low-bound</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">prime-seq</span> <span class="p">[</span><span class="nv">low-bound</span><span class="p">]</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">prime?</span> <span class="p">(</span><span class="nf">range-to-inf</span> <span class="nv">low-bound</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">1000</span> <span class="mi">10000</span> <span class="mi">100000</span> <span class="mi">1000000</span><span class="p">]]</span>
    <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nf">prime-seq</span> <span class="nv">x</span><span class="p">)))))</span>
</code></pre></div><p>Output:</p>
<blockquote>
<p>(1009 1013 1019)</p>
<p>“Elapsed time: 0.676343 msecs”</p>
<p>(10007 10009 10037)</p>
<p>“Elapsed time: 1.799251 msecs”</p>
<p>(100003 100019 100043)</p>
<p>“Elapsed time: 2.813975 msecs”</p>
<p>(1000003 1000033 1000037)</p>
<p>“Elapsed time: 2.98355 msecs”</p>
<p>nil</p>
</blockquote>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/sicp-solutions-in-clojure-chapter-1/1-22-time-input-scale-line-plot.svg"
        data-srcset="/images/sicp-solutions-in-clojure-chapter-1/1-22-time-input-scale-line-plot.svg, /images/sicp-solutions-in-clojure-chapter-1/1-22-time-input-scale-line-plot.svg 1.5x, /images/sicp-solutions-in-clojure-chapter-1/1-22-time-input-scale-line-plot.svg 2x"
        data-sizes="auto"
        alt="/images/sicp-solutions-in-clojure-chapter-1/1-22-time-input-scale-line-plot.svg"
        title="A line with a sqaure-root-function look." /></p>
<p>This verrified the assumption of the order of growth of the <code>prime?</code> function.</p>
<h3 id="exercise-123">Exercise 1.23</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">smallest-divisor</span>
  <span class="p">([</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">smallest-divisor</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">]</span> <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">* </span><span class="nv">test-divisor</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">n</span>
                          <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">test-divisor</span>
                          <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">test-divisor</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">smallest-divisor-improved</span>
  <span class="p">([</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">smallest-divisor-improved</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">]</span> <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">* </span><span class="nv">test-divisor</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">n</span>
                          <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">test-divisor</span>
                          <span class="ss">:else</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">n</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">test-divisor</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">test-divisor</span> <span class="mi">2</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">1009</span> <span class="mi">1013</span> <span class="mi">1019</span> <span class="mi">10007</span> <span class="mi">10009</span> <span class="mi">10037</span> <span class="mi">100003</span> <span class="mi">100019</span> <span class="mi">100043</span> <span class="mi">1000003</span> <span class="mi">1000033</span> <span class="mi">1000037</span><span class="p">]</span>
       <span class="nv">y</span> <span class="p">[</span><span class="nv">smallest-divisor</span> <span class="nv">smallest-divisor-improved</span><span class="p">]]</span>
  <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&#34;Testing &#34;</span> <span class="nv">x</span> <span class="s">&#34; on &#34;</span> <span class="nv">y</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">y</span> <span class="nv">x</span><span class="p">))))</span>
</code></pre></div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/sicp-solutions-in-clojure-chapter-1/1-23-time-input-scale-line-plot.svg"
        data-srcset="/images/sicp-solutions-in-clojure-chapter-1/1-23-time-input-scale-line-plot.svg, /images/sicp-solutions-in-clojure-chapter-1/1-23-time-input-scale-line-plot.svg 1.5x, /images/sicp-solutions-in-clojure-chapter-1/1-23-time-input-scale-line-plot.svg 2x"
        data-sizes="auto"
        alt="/images/sicp-solutions-in-clojure-chapter-1/1-23-time-input-scale-line-plot.svg"
        title="Two lines having a portion less than 2" /></p>
<p>A guess: Executing the if statements cost time.</p>
<h3 id="exercise-124">Exercise 1.24</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">expmod</span>
  <span class="s">&#34;Calculate a^b%p&#34;</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">p</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">1</span>
        <span class="p">(</span><span class="nf">even?</span> <span class="nv">b</span><span class="p">)</span>
          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">h</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">p</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="nb">* </span><span class="nv">h</span> <span class="nv">h</span><span class="p">)</span> <span class="nv">p</span><span class="p">))</span>
        <span class="ss">:else</span>
          <span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">- </span><span class="nv">b</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">p</span><span class="p">))</span> <span class="nv">p</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fermat-test</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">rnd</span> <span class="p">(</span><span class="nf">bigint</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">rand </span><span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))]</span>
    <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">expmod</span> <span class="nv">rnd</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">rnd</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fast-prime?</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">times</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">times</span><span class="p">)</span> <span class="nv">true</span>
        <span class="p">(</span><span class="nf">fermat-test</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">- </span><span class="nv">times</span> <span class="mi">1</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="nv">false</span><span class="p">))</span>
<span class="p">(</span><span class="nf">fast-prime?</span> <span class="mi">1000000007</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">1009</span> <span class="mi">1013</span> <span class="mi">1019</span> <span class="mi">10007</span> <span class="mi">10009</span> <span class="mi">10037</span> <span class="mi">100003</span> <span class="mi">100019</span> <span class="mi">100043</span> <span class="mi">1000003</span> <span class="mi">1000033</span> <span class="mi">1000037</span><span class="p">]]</span>
  <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">fast-prime?</span> <span class="nv">x</span> <span class="mi">1000</span><span class="p">)))</span>
</code></pre></div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/sicp-solutions-in-clojure-chapter-1/1-24-time-input-scale-line-plot.svg"
        data-srcset="/images/sicp-solutions-in-clojure-chapter-1/1-24-time-input-scale-line-plot.svg, /images/sicp-solutions-in-clojure-chapter-1/1-24-time-input-scale-line-plot.svg 1.5x, /images/sicp-solutions-in-clojure-chapter-1/1-24-time-input-scale-line-plot.svg 2x"
        data-sizes="auto"
        alt="/images/sicp-solutions-in-clojure-chapter-1/1-24-time-input-scale-line-plot.svg"
        title="A line with an log-function look, however a point is strange" /></p>
<p>This nearly consistents with my guess that the time consumed is proportional to the order of the magnitude of the input.</p>
<p>However a strange point does not consist with my guess.</p>
<h3 id="exercise-125">Exercise 1.25</h3>
<p>She is wrong. The memory is limited, so there&rsquo;s no point to store a huge number.</p>
<p>If we compute exponentials then take remainders, it may overflow in many cases.</p>
<p>On the contrary, taking remainders after every time we do a multiplication will reduce the probability of math overflow.</p>
<h3 id="exercise-126">Exercise 1.26</h3>
<p>$$
\begin{aligned}
&amp;T(n) &amp;=&amp; \left{ \begin{aligned}
&amp; 2T(\frac{n}{2}) + O(1) &amp;, &amp;n \equiv 0 \pmod 2&amp; \<br>
&amp; T(n-1) + O(1) &amp;, &amp; n \equiv 1 \pmod 2&amp;
\end{aligned}\right. &amp;\<br>
&amp;&amp;=&amp;\Theta(n+\log n)&amp;\<br>
&amp;&amp;=&amp;O(n)&amp;
\end{aligned}
$$</p>
<h3 id="exercise-127">Exercise 1.27</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">expmod</span>
  <span class="s">&#34;Calculate a^b%p&#34;</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">p</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">1</span>
        <span class="p">(</span><span class="nf">even?</span> <span class="nv">b</span><span class="p">)</span>
          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">h</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">p</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="nb">* </span><span class="nv">h</span> <span class="nv">h</span><span class="p">)</span> <span class="nv">p</span><span class="p">))</span>
        <span class="ss">:else</span>
          <span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">- </span><span class="nv">b</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">p</span><span class="p">))</span> <span class="nv">p</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">carmichael?</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nb">every? </span><span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">expmod</span> <span class="nv">%</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span> <span class="nv">n</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">every? </span><span class="nv">carmichael?</span> <span class="p">[</span><span class="mi">561</span> <span class="mi">1105</span> <span class="mi">1729</span> <span class="mi">2465</span> <span class="mi">2821</span> <span class="mi">6601</span><span class="p">])</span>
</code></pre></div><h3 id="exercise-128">Exercise 1.28</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">expmod</span>
  <span class="s">&#34;Calculate a^b%p&#34;</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">p</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">1</span>
        <span class="p">(</span><span class="nf">even?</span> <span class="nv">b</span><span class="p">)</span>
          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">h</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">sq</span> <span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="nb">* </span><span class="nv">h</span> <span class="nv">h</span><span class="p">)</span> <span class="nv">p</span><span class="p">)]</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">sq</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">not= </span><span class="nv">h</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">not= </span><span class="nv">h</span> <span class="p">(</span><span class="nb">- </span><span class="nv">p</span> <span class="mi">1</span><span class="p">)))</span> <span class="mi">0</span> <span class="nv">sq</span><span class="p">))</span>
        <span class="ss">:else</span>
          <span class="p">(</span><span class="nb">rem </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">- </span><span class="nv">b</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">p</span><span class="p">))</span> <span class="nv">p</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">miller-rabin</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">rnd</span> <span class="p">(</span><span class="nf">bigint</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">rand </span><span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))]</span>
    <span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nf">expmod</span> <span class="nv">rnd</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fast-prime?</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">times</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">times</span><span class="p">)</span> <span class="nv">true</span>
        <span class="p">(</span><span class="nf">miller-rabin</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">- </span><span class="nv">times</span> <span class="mi">1</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="nv">false</span><span class="p">))</span>

<span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">(</span><span class="nf">fast-prime?</span> <span class="nv">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">[</span><span class="mi">561</span> <span class="mi">1105</span> <span class="mi">1729</span> <span class="mi">2465</span> <span class="mi">2821</span> <span class="mi">6601</span><span class="p">])</span>
</code></pre></div><h3 id="exercise-129">Exercise 1.29</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">cube</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span> <span class="nv">%</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">sum</span> <span class="o">#</span><span class="p">(</span><span class="nb">reduce + </span><span class="nv">%</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">integral</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">dx</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">* </span><span class="nv">dx</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="p">(</span><span class="nb">range </span><span class="nv">a</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">b</span> <span class="nv">dx</span><span class="p">)</span> <span class="nv">dx</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">simpson</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">h</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="nv">b</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">h2</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">h</span> <span class="nv">h</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">/ </span><span class="nv">h</span> <span class="mi">3</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">b</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="p">(</span><span class="nb">range </span><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">h2</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">b</span> <span class="nv">h</span><span class="p">)</span> <span class="nv">h2</span><span class="p">))))</span>
         <span class="p">(</span><span class="nb">* </span><span class="mi">4</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="p">(</span><span class="nb">range </span><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">h</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">h2</span><span class="p">))))))))</span>

<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&#34;dx=0.01: &#34;</span> <span class="p">(</span><span class="nf">integral</span> <span class="nv">cube</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">100</span><span class="p">))</span> <span class="s">&#34; &#34;</span> <span class="p">(</span><span class="nf">simpson</span> <span class="nv">cube</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">100</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&#34;dx=0.001: &#34;</span> <span class="p">(</span><span class="nf">integral</span> <span class="nv">cube</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">1000</span><span class="p">))</span> <span class="s">&#34; &#34;</span> <span class="p">(</span><span class="nf">simpson</span> <span class="nv">cube</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1000</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-130">Exercise 1.30</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">sum</span> <span class="p">[</span><span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">]</span> <span class="c1">; avoid using 0 since the function might work not only for numbers</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">iter</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">result</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">term</span> <span class="nv">b</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">next </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">term</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">result</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">iter</span> <span class="p">(</span><span class="nb">next </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-131">Exercise 1.31</h3>
<h4 id="a-1">a)</h4>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">product</span> <span class="p">[</span><span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">product</span> <span class="nv">term</span> <span class="p">(</span><span class="nb">next </span><span class="nv">a</span><span class="p">)</span> <span class="nb">next </span><span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">factorial</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">product</span> <span class="nb">identity </span><span class="mi">1</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">approximate-pi-quarter</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">product</span> <span class="o">#</span><span class="p">(</span><span class="nb">double </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">)))</span> <span class="mi">3</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre></div><h4 id="b">b)</h4>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">product</span>
  <span class="p">([</span><span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">product</span> <span class="nv">term</span> <span class="p">(</span><span class="nb">next </span><span class="nv">a</span><span class="p">)</span> <span class="nb">next </span><span class="nv">b</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)))</span>
  <span class="p">([</span><span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span> <span class="nv">result</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">result</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">term</span> <span class="p">(</span><span class="nb">next </span><span class="nv">a</span><span class="p">)</span> <span class="nb">next </span><span class="nv">b</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">result</span><span class="p">)))))</span>
</code></pre></div><h3 id="exercise-132">Exercise 1.32</h3>
<p>Actually, <code>accumulate</code> is the function <code>reduce</code> implemented in Clojure.</p>
<p>There is a difference, that is accumulate is right-fold while reduce is left-fold.</p>
<p>See [more about fold on wikipedia](<a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">https://en.wikipedia.org/wiki/Fold_(higher-order_function)</a>.</p>
<h4 id="a-2">a)</h4>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">accumulate</span> <span class="p">[</span><span class="nv">combiner</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">combiner</span> <span class="nv">null-value</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">recur</span> <span class="nv">combiner</span> <span class="p">(</span><span class="nf">combiner</span> <span class="nv">null-value</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">))</span> <span class="nv">term</span> <span class="p">(</span><span class="nb">next </span><span class="nv">a</span><span class="p">)</span> <span class="nb">next </span><span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">sum</span> <span class="p">[</span><span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nf">accumulate</span> <span class="nb">+ </span><span class="mi">0</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">product</span> <span class="p">[</span><span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nf">accumulate</span> <span class="nb">* </span><span class="mi">1</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">))</span>
</code></pre></div><h4 id="b-1">b)</h4>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">accumulate</span> <span class="p">[</span><span class="nv">combiner</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">combiner</span> <span class="nv">null-value</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">combiner</span> <span class="nv">a</span> <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">combiner</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="p">(</span><span class="nb">next </span><span class="nv">a</span><span class="p">)</span> <span class="nb">next </span><span class="nv">b</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-133">Exercise 1.33</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">filtered-accumulate</span> <span class="p">[</span><span class="nv">combiner</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nb">next </span><span class="nv">b</span> <span class="nv">predicate</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">predicate</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">combiner</span> <span class="nv">null-value</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">null-value</span><span class="p">)</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">predicate</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">combiner</span> <span class="p">(</span><span class="nf">combiner</span> <span class="nv">null-value</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">))</span> <span class="nv">term</span> <span class="p">(</span><span class="nb">next </span><span class="nv">a</span><span class="p">)</span> <span class="nb">next </span><span class="nv">b</span> <span class="nv">predicate</span><span class="p">)</span>
                                <span class="p">(</span><span class="nf">recur</span> <span class="nv">combiner</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="p">(</span><span class="nb">next </span><span class="nv">a</span><span class="p">)</span> <span class="nb">next </span><span class="nv">b</span> <span class="nv">predicate</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">prime?</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">every? </span><span class="o">#</span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nf">mod</span> <span class="nv">x</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nf">Math/sqrt</span> <span class="nv">x</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">func-a</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nf">filtered-accumulate</span> <span class="nb">+ </span><span class="mi">0</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">a</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">prime?</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">gcd</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">rem </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">func-b</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">filtered-accumulate</span> <span class="nb">* </span><span class="mi">1</span> <span class="nb">identity </span><span class="mi">2</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">gcd</span> <span class="nv">%</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-134">Exercise 1.34</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[</span><span class="nv">g</span><span class="p">]</span> <span class="p">(</span><span class="nf">g</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="nf">f</span> <span class="nv">f</span><span class="p">)</span><span class="c1">; =&gt;</span>

<span class="p">(</span><span class="nf">f</span> <span class="mi">2</span><span class="p">)</span><span class="c1">; =&gt;</span>

<span class="c1">; Execution error (ClassCastException) at user/f (REPL:1).</span>
<span class="c1">; class java.lang.Long cannot be cast to class clojure.lang.IFn.</span>

</code></pre></div><h3 id="exercise-135">Exercise 1.35</h3>
<p>$$
\phi = \frac{\sqrt5+1}2, \frac1\phi+1 = \frac{\sqrt5+1}2 = \phi
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">tolerance</span> <span class="mi">1</span><span class="nv">e-5</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">abs</span> <span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">%</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">%</span><span class="p">)</span> <span class="nv">%</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fixed-point</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">initial</span><span class="p">]</span>
  <span class="p">(</span><span class="k">def </span><span class="nv">close?</span> <span class="o">#</span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">abs</span> <span class="p">(</span><span class="nb">- </span><span class="nv">%1</span> <span class="nv">%2</span><span class="p">))</span> <span class="nv">tolerance</span><span class="p">))</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">_try</span> <span class="p">[</span><span class="nv">guess</span><span class="p">]</span> <span class="c1">; `try` is a special form in Clojure.</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">next </span><span class="p">(</span><span class="nf">f</span> <span class="nv">guess</span><span class="p">)]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">close?</span> <span class="nv">guess</span> <span class="nv">next</span><span class="p">)</span> <span class="nb">next </span><span class="p">(</span><span class="nf">recur</span> <span class="nv">next</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">_try</span> <span class="nv">initial</span><span class="p">))</span>

<span class="p">(</span><span class="nf">fixed-point</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">%</span><span class="p">))</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><h3 id="exercise-136">Exercise 1.36</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">tolerance</span> <span class="mi">1</span><span class="nv">e-5</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">abs</span> <span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">%</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">%</span><span class="p">)</span> <span class="nv">%</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fixed-point</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">initial</span><span class="p">]</span>
  <span class="p">(</span><span class="k">def </span><span class="nv">close?</span> <span class="o">#</span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">abs</span> <span class="p">(</span><span class="nb">- </span><span class="nv">%1</span> <span class="nv">%2</span><span class="p">))</span> <span class="nv">tolerance</span><span class="p">))</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">_try</span> <span class="p">[</span><span class="nv">guess</span><span class="p">]</span> <span class="c1">; `try` is a special form in Clojure.</span>
    <span class="p">(</span><span class="nb">println </span><span class="nv">guess</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">next </span><span class="p">(</span><span class="nf">f</span> <span class="nv">guess</span><span class="p">)]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">close?</span> <span class="nv">guess</span> <span class="nv">next</span><span class="p">)</span> <span class="nb">next </span><span class="p">(</span><span class="nf">recur</span> <span class="nv">next</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">_try</span> <span class="nv">initial</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">average-damp</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="o">#</span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">identity </span><span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">%</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">f</span> <span class="o">#</span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">Math/log</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/log</span> <span class="nv">%</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">fixed-point</span> <span class="nv">f</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">println</span><span class="p">)</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="p">(</span><span class="nf">average-damp</span> <span class="nv">f</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><p>Output:</p>
<blockquote>
<p>9.965784284662087</p>
<p>3.004472209841214</p>
<p>6.279195757507157</p>
<p>3.759850702401539</p>
<p>5.215843784925895</p>
<p>4.182207192401397</p>
<p>4.8277650983445906</p>
<p>4.387593384662677</p>
<p>4.671250085763899</p>
<p>4.481403616895052</p>
<p>4.6053657460929</p>
<p>4.5230849678718865</p>
<p>4.577114682047341</p>
<p>4.541382480151454</p>
<p>4.564903245230833</p>
<p>4.549372679303342</p>
<p>4.559606491913287</p>
<p>4.552853875788271</p>
<p>4.557305529748263</p>
<p>4.554369064436181</p>
<p>4.556305311532999</p>
<p>4.555028263573554</p>
<p>4.555870396702851</p>
<p>4.555315001192079</p>
<p>4.5556812635433275</p>
<p>4.555439715736846</p>
<p>4.555599009998291</p>
<p>4.555493957531389</p>
<p>4.555563237292884</p>
<p>4.555517548417651</p>
<p>4.555547679306398</p>
<p>4.555527808516254</p>
<p>4.555540912917957</p>
<p>4.555532270803653</p>
<p>~</p>
<p>5.9828921423310435</p>
<p>4.922168721308343</p>
<p>4.628224318195455</p>
<p>4.568346513136242</p>
<p>4.5577305909237005</p>
<p>4.555909809045131</p>
<p>4.555599411610624</p>
<p>4.5555465521473675</p>
<p>4.555537551999825</p>
</blockquote>
<p>Without average-damping, the fixed-point function took 34 steps;</p>
<p>With average-damping, the fixed-point function took 9 steps.</p>
<p>Notice: average-damping won&rsquo;t always improve the performance of your program. you can try this:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">f</span> <span class="o">#</span><span class="p">(</span><span class="nb">/ </span><span class="nv">%</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="nv">f</span> <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">println</span><span class="p">)</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="p">(</span><span class="nf">average-damp</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span>
</code></pre></div><p>Average-damping improve the performance of the fixed-point function, if the applying multiple times f on some x results in the output keeping taking turns.</p>
<p>That property doesn&rsquo;t hold for every function.</p>
<h3 id="exercise-137">Exercise 1.37</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">cont-frac</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">d</span> <span class="nv">k</span><span class="p">]</span> <span class="p">(</span><span class="nf">cont-frac</span> <span class="nv">n</span> <span class="nv">d</span> <span class="nv">k</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">d</span> <span class="nv">k</span> <span class="nv">result</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">result</span>
                <span class="p">(</span><span class="nf">recur</span> <span class="nv">n</span> <span class="nv">d</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">n</span> <span class="nv">k</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">result</span> <span class="p">(</span><span class="nf">d</span> <span class="nv">k</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">c1</span> <span class="p">(</span><span class="nb">constantly </span><span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">double </span><span class="p">(</span><span class="nf">cont-frac</span> <span class="nv">c1</span> <span class="nv">c1</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">;=&gt; 0.6179775280898876</span>
<span class="p">(</span><span class="nb">double </span><span class="p">(</span><span class="nf">cont-frac</span> <span class="nv">c1</span> <span class="nv">c1</span> <span class="mi">11</span><span class="p">))</span> <span class="c1">;=&gt; 0.6180555555555556</span>
</code></pre></div><h3 id="exercise-138">Exercise 1.38</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">d</span> <span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rem </span><span class="nv">%</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="nv">/3</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="p">(</span><span class="nf">cont-frac</span> <span class="p">(</span><span class="nb">constantly </span><span class="mi">1</span><span class="p">)</span> <span class="nv">d</span> <span class="mi">100</span> <span class="mf">0.0</span><span class="p">))</span> <span class="c1">; Use double initial to avoid ratio (ratio is slow)</span>
</code></pre></div><h3 id="exercise-139">Exercise 1.39</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">tan-cf</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">k</span><span class="p">]</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">cont-frac</span> <span class="p">(</span><span class="nb">constantly </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span> <span class="o">#</span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">k</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-140">Exercise 1.40</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">dx</span> <span class="mi">1</span><span class="nv">e-5</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">deriv</span> <span class="p">[</span><span class="nv">g</span><span class="p">]</span> <span class="o">#</span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">g</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="nv">dx</span><span class="p">))</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">%</span><span class="p">))</span> <span class="nv">dx</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">newton-transform</span> <span class="p">[</span><span class="nv">g</span><span class="p">]</span> <span class="o">#</span><span class="p">(</span><span class="nb">- </span><span class="nv">%</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">g</span> <span class="nv">%</span><span class="p">)</span> <span class="p">((</span><span class="nf">deriv</span> <span class="nv">g</span><span class="p">)</span> <span class="nv">%</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">newtons-method</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">initial</span><span class="p">]</span> <span class="p">(</span><span class="nf">fixed-point</span> <span class="p">(</span><span class="nf">newton-transform</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">initial</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">cubic</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">b</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>
</code></pre></div><h3 id="exercise-141">Exercise 1.41</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">_double</span> <span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="o">#</span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">%</span><span class="p">)))</span>

<span class="p">(((</span><span class="nf">_double</span> <span class="p">(</span><span class="nf">_double</span> <span class="nv">_double</span><span class="p">))</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span><span class="c1">; =&gt; 21</span>

</code></pre></div><h3 id="exercise-142">Exercise 1.42</h3>
<p><code>compose</code> is built-in in Clojure as <code>comp</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">compose</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">g</span><span class="p">]</span> <span class="o">#</span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">%</span><span class="p">)))</span>
</code></pre></div><h3 id="exercise-143">Exercise 1.43</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">repeated</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">n</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="nb">identity </span><span class="o">#</span><span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">%</span><span class="p">))))</span>
</code></pre></div><h3 id="exercise-144">Exercise 1.44</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">dx</span> <span class="mi">1</span><span class="nv">e-5</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">smooth</span>
  <span class="p">([</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="nf">smooth</span> <span class="nv">f</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">f</span> <span class="nv">n</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">f</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">g</span> <span class="p">(</span><span class="nf">smooth</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))]</span>
        <span class="o">#</span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">g</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="p">(</span><span class="nb">- </span><span class="nv">%</span> <span class="nv">dx</span><span class="p">))</span> <span class="p">(</span><span class="nf">g</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="nv">dx</span><span class="p">)))</span> <span class="mi">3</span><span class="p">)))))</span>
</code></pre></div><h3 id="exercise-145">Exercise 1.45</h3>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">iterative-improve</span>
  <span class="p">[</span><span class="nv">good?</span> <span class="nv">improve</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">initial</span><span class="p">]</span>
    <span class="p">(</span><span class="kd">defn </span><span class="nv">_try</span> <span class="p">[</span><span class="nv">guess</span><span class="p">]</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">next </span><span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span><span class="p">)]</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">good?</span> <span class="nv">guess</span><span class="p">)</span> <span class="nb">next </span><span class="p">(</span><span class="nf">recur</span> <span class="nv">next</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">_try</span> <span class="nv">initial</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">tolerance</span> <span class="mi">1</span><span class="nv">e-5</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">abs</span> <span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">%</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">%</span><span class="p">)</span> <span class="nv">%</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">close?</span> <span class="o">#</span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">abs</span> <span class="p">(</span><span class="nb">- </span><span class="nv">%1</span> <span class="nv">%2</span><span class="p">))</span> <span class="nv">tolerance</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fixed-point</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">initial</span><span class="p">]</span> <span class="p">((</span><span class="nf">iterative-improve</span> <span class="o">#</span><span class="p">(</span><span class="nf">close?</span> <span class="nv">%</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">%</span><span class="p">))</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">initial</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">sqrt</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">improve</span> <span class="p">[</span><span class="nv">guess</span><span class="p">]</span> <span class="p">(</span><span class="nb">double </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="nv">guess</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">guess</span><span class="p">))</span> <span class="mi">2</span><span class="p">)))</span>
  <span class="p">((</span><span class="nf">iterative-improve</span> <span class="o">#</span><span class="p">(</span><span class="nf">close?</span> <span class="nv">%</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">%</span><span class="p">))</span> <span class="nv">improve</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span></span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/algorithms/">algorithms</a>,&nbsp;<a href="/tags/principles/">principles</a>,&nbsp;<a href="/tags/lisp/">LISP</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();"></a></span>&nbsp;|&nbsp;<span><a href="/"></a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/sicp-solutions-in-clojure-chapter-2/" class="prev" rel="prev" title="SICP Solutions in Clojure (Chapter 2)"><i class="fas fa-angle-left fa-fw"></i>SICP Solutions in Clojure (Chapter 2)</a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer">lyhokia</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><link rel="stylesheet" href="/lib/mermaid/mermaid.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript" src="/lib/mermaid/mermaid.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"","maxShownLines":10},"comment":{},"data":{"id-1":"graph TD;\nA{\"f(11, 5)\"} --\u003e B(\"f(-39, 5)\")\nA --\u003e C{\"f(11, 4)\"}\nC --\u003e D(\"f(-14, 4)\")\nC --\u003e E{\"f(11, 3)\"}\nE --\u003e F{\"f(1, 3)\"}\nE --\u003e G{\"f(11, 2)\"}\nF --\u003e H(\"f(-9, 3)\")\nF --\u003e I{\"f(1, 2)\"}\nG --\u003e J{\"f(6, 2)\"}\nG --\u003e K{\"f{11,1}\"}\nI --\u003e L(\"f(-4, 2)\")\nI --\u003e M{\"f(1, 1)\"}\nM --\u003e N(\"f(0, 1)\")\nstyle N fill:#4caf50\nM --\u003e O(\"f(1, 0)\")\nJ --\u003e I\nK --\u003e P{\"f(10, 1)\"}\nK --\u003e Q(\"f(11, 0)\")\nP --\u003e R{\"f(9, 1)\"}\nP --\u003e S(\"f(10, 0)\")\nR --\u003e T{\"f(8, 1)\"}\nR --\u003e U(\"f(9, 0)\")\nT --\u003e V{\"f(7, 1)\"}\nT --\u003e W(\"f(8, 0)\")\nV --\u003e X{\"f(6, 1)\"}\nJ --\u003e X\nV --\u003e Y(\"f(7, 0)\")\nX --\u003e Z{\"f(5, 1)\"}\nX --\u003e AA(\"f(6, 0)\")\nZ --\u003e AB{\"f(4, 1)\"}\nZ --\u003e AC(\"f(5, 0)\")\nAB --\u003e AD{\"f(3, 1)\"}\nAB --\u003e AE(\"f(4, 0)\")\nAD --\u003e AF{\"f(2, 1)\"}\nAD --\u003e AG(\"f(3, 0)\")\nAF --\u003e M\nAF --\u003e AH(\"f(2, 0)\")"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
